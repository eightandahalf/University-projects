--P.S.
-- после изменения размера некоторых столбцов таблицы orders, расположения некоторых 
-- стобцов изменились по сравнению с первоначальным положением, поэтому первые insert
-- в таблицу orders можно не использовать как верные, т.к. таблица изменилась структурно,
-- но менять по 100 раз старый код не вижу смысла.
-- этот момент вылез при создании процедуры в 4 лабе, когда заказы перемещаю в другую таблицу.
-- create table orders я переделал, но первые insert-ы в эту таблицу остались прежними
-- и в дальнейшей работе с бд, приходилось добавлять новые столбцы в таблицу orders, поэтому 
-- чтобы понимать все столбцы в ней, лучше ориентировать на процедуру в 4 лабе


CREATE TABLE Manufacturers(Manufact_code INTEGER generated by default as identity(nocache),
                    MNF_name VARCHAR2(30) NOT NULL,
                    MNF_office_address VARCHAR2(40) NOT NULL,
					MNF_ceo_phone CHAR(17) NOT NULL,
                    PRIMARY KEY(Manufact_code),
                    CONSTRAINT MNF_uni_dir_phone UNIQUE(MNF_ceo_phone));

ALTER TABLE Manufacturers
ADD CONSTRAINT MNF_dir_phone
	CHECK(REGEXP_LIKE(MNF_ceo_phone, '^\+375\(\d{2}\)\d{3}-\d{2}-\d{2}$'));


CREATE TABLE Education_levels(EDCT_LVL_code INTEGER generated by default as identity(nocache),
                    EDCT_LVL_educational_background VARCHAR2(40) NOT NULL,
                    PRIMARY KEY(EDCT_LVL_code),
                    CONSTRAINT EDCT_LVF_educ_back UNIQUE(EDCT_LVL_educational_background));

CREATE TABLE Positions(Position_code INTEGER generated by default as identity(nocache),
                    PST_name VARCHAR2(30) NOT NULL,
                    PST_min_level_of_education_code INTEGER NOT NULL,
                    PST_min_salary INTEGER NOT NULL,
					PST_employee_availability VARCHAR2(3) NOT NULL,	
					PST_driver_license VARCHAR2(3) NOT NULL,
					PST_english_A2_required VARCHAR2(3) NOT NULL,
                    PRIMARY KEY(Position_code),
                    CONSTRAINT PST_avail_of_empl
                               CHECK(PST_employee_availability IN('Yes','No')),
					CONSTRAINT PST_drive_license
							   CHECK(PST_driver_license IN('Yes','No')),
					CONSTRAINT PST_english_req
							   CHECK(PST_english_A2_required IN('Yes','No')),
					CONSTRAINT PST_min_lvl_educ
							   FOREIGN KEY(PST_min_level_of_education_code)
							   REFERENCES Education_levels(EDCT_LVL_code) ON DELETE CASCADE);
							   
CREATE TABLE Vehicles_sellers(Seller_code INTEGER generated by default as identity(nocache),
                    SLR_phone CHAR(17) NOT NULL,
                    PRIMARY KEY(Seller_code),
                    CONSTRAINT SLR_phone_num
                                CHECK(REGEXP_LIKE(SLR_phone, '^\+375\(\d{2}\)\d{3}-\d{2}-\d{2}$')),
                    CONSTRAINT SLR_uni_phone UNIQUE(SLR_phone));

CREATE TABLE Orders(Order_num INTEGER generated by default as identity(nocache),
					ORD_sender_name VARCHAR2(40) NOT NULL,
					ORD_sender_address VARCHAR2(50) NOT NULL,
					ORD_sender_phone CHAR(17) NOT NULL,
					ORD_sending_office INTEGER NOT NULL,
					ORD_employee_placing_the_order_num INTEGER NOT NULL,
					ORD_package_weight DECIMAL(20,3) NOT NULL,
					ORD_package_scope DECIMAL(20,3) NOT NULL,
                    ORD_package_receipt_date DATE NOT NULL,
					ORD_declared_value_amount DECIMAL(30,3),
					ORD_cash_on_dlvry_amount DECIMAL(30,3),
					ORD_fragile VARCHAR2(3) NOT NULL,
					ORD_completeness_check VARCHAR2(3) NOT NULL,
                    ORD_arrival_date DATE,
					ORD_recipient_name VARCHAR2(40) NOT NULL,
					ORD_recipient_address VARCHAR2(50) NOT NULL,
					ORD_recipient_phone CHAR(17) NOT NULL,
					ORD_receiving_office INTEGER NOT NULL,
					ORD_shipping_cost DECIMAL(30,3) NOT NULL,
					ORD_deliv_type_code INTEGER NOT NULL,
					ORD_cash_payment VARCHAR2(3) NOT NULL,
					PRIMARY KEY(Order_num),
					CONSTRAINT ORD_sending_officce
							   FOREIGN KEY(ORD_sending_office)
							   REFERENCES Branch(Branch_num) ON DELETE CASCADE,
					CONSTRAINT ORD_receiving_office_num
							   FOREIGN KEY(ORD_receiving_office)
							   REFERENCES Branch(Branch_num) ON DELETE CASCADE,
					CONSTRAINT ORD_delivery_type_code
							   FOREIGN KEY(ORD_deliv_type_code)
							   REFERENCES Delivery_type(DLV_code) ON DELETE CASCADE,
					CONSTRAINT ORD_completeness_checking
							   CHECK(ORD_completeness_check IN('Yes','No')),
					CONSTRAINT ORD_cash_or_visa_payment
							   CHECK(ORD_cash_payment IN('Yes','No')),
					CONSTRAINT ORD_fragile_package
							   CHECK(ORD_fragile IN('Yes','No')),
					CONSTRAINT ORD_employ_placing_order_num
							   FOREIGN KEY(ORD_employee_placing_the_order_num)
							   REFERENCES Staff(Staff_num) ON DELETE CASCADE,
					CONSTRAINT ORD_recipient_phone_num
                               CHECK(REGEXP_LIKE(ORD_recipient_phone, '^\+375\(\d{2}\)\d{3}-\d{2}-\d{2}$')),
					CONSTRAINT ORD_sender_phone_num
                               CHECK(REGEXP_LIKE(ORD_sender_phone, '^\+375\(\d{2}\)\d{3}-\d{2}-\d{2}$')));  

CREATE TABLE Delivery_type(DLV_code INTEGER generated by default as identity(nocache),
                    DLV_delivery_method VARCHAR2(25) NOT NULL,
                    PRIMARY KEY(DLV_code),
                    CONSTRAINT DLV_unique_deliv_method UNIQUE(DLV_delivery_method));
	
CREATE TABLE Basket(Basket_code INTEGER generated by default as identity(nocache),
					Departure_num INTEGER NOT NULL,
                    Order_num INTEGER NOT NULL,
					CONSTRAINT Basket_departure_num_constr
							   FOREIGN KEY(Departure_num)
							   REFERENCES Departure(Departure_num) ON DELETE CASCADE,
					CONSTRAINT Basket_order_num_constr
							   FOREIGN KEY(Order_num)
							   REFERENCES Orders(Order_num)ON DELETE CASCADE);
							   
CREATE TABLE Vehicle(Vehicle_code INTEGER generated by default as identity(nocache),
					VIN VARCHAR2(20) NOT NULL,
                    VHC_model VARCHAR2(30) NOT NULL,
					VHC_gear_code INTEGER NOT NULL,
                    VHC_manufact_code INTEGER NOT NULL,
					VHC_max_load_capacity DECIMAL(30,3) NOT NULL,
					VHC_release_year DATE NOT NULL,
					VHC_inspection_date DATE NOT NULL,
					VHC_seller_code INTEGER NOT NULL,
                    PRIMARY KEY(Vehicle_code),
					CONSTRAINT VHC_sellers_code
							   FOREIGN KEY(VHC_seller_code)
							   REFERENCES Vehicles_sellers(Seller_code)ON DELETE CASCADE,
					CONSTRAINT VHC_manufacture_code
							   FOREIGN KEY(VHC_manufact_code)
							   REFERENCES Manufacturers(Manufact_code)ON DELETE CASCADE,
					CONSTRAINT VHC_gearbox_code
							   FOREIGN KEY(VHC_gear_code)
							   REFERENCES Gearbox(GEAR_code)ON DELETE CASCADE,
					CONSTRAINT VHC_unique_vin UNIQUE(VIN));

CREATE TABLE Gearbox(GEAR_code INTEGER generated by default as identity(nocache),
                    GEAR_type VARCHAR2(20) NOT NULL,
                    PRIMARY KEY(GEAR_code));
					
ALTER TABLE Gearbox
ADD CONSTRAINT GEAR_unique_type UNIQUE(GEAR_type);
					
CREATE TABLE Branch(Branch_num INTEGER generated by default as identity(nocache),
                    BR_max_storage_capacity DECIMAL(8,2) NOT NULL,
					BR_principal_employee_name VARCHAR2(30) NOT NULL,
					BR_principal_employee_phone CHAR(17) NOT NULL,
					BR_address VARCHAR2(50) NOT NULL,
					BR_employee_num INTEGER,
					BR_ceo_director INTEGER NOT NULL,
					PRIMARY KEY(Branch_num),
					CONSTRAINT BR_princ_employee_phone_num
                               CHECK(REGEXP_LIKE(BR_principal_employee_phone, '^\+375\(\d{2}\)\d{3}-\d{2}-\d{2}$')));

ALTER TABLE Branch
ADD CONSTRAINT BR_ceo
	   FOREIGN KEY(BR_ceo_director)
	   REFERENCES Staff(Staff_num)ON DELETE CASCADE;


CREATE TABLE Staff(Staff_num INTEGER generated by default as identity(nocache),
                    STF_name VARCHAR2(30) NOT NULL,
					STF_birth_date DATE NOT NULL,
					STF_address VARCHAR2(50) NOT NULL,
					STF_position_code INTEGER NOT NULL,
					STF_email VARCHAR2(30) NOT NULL,
					STF_passport_details VARCHAR2(30) NOT NULL,
					STF_branch_num INTEGER NOT NULL,
					STF_phone_num CHAR(17) NOT NULL,
					PRIMARY KEY(Staff_num),
					CONSTRAINT STF_position__code
							   FOREIGN KEY(STF_position_code)
							   REFERENCES Positions(Position_code)ON DELETE CASCADE,
					CONSTRAINT STF_branch_number
							   FOREIGN KEY(STF_branch_num)
							   REFERENCES Branch(Branch_num)ON DELETE CASCADE,
					CONSTRAINT STF_phone_num
                               CHECK(REGEXP_LIKE(STF_phone_num, '^\+375\(\d{2}\)\d{3}-\d{2}-\d{2}$')));
		
CREATE TABLE Departure(Departure_num INTEGER generated by default as identity(nocache),
                    Vehicle_code INTEGER NOT NULL,
					DPTR_sending_office_address VARCHAR2(50) NOT NULL,
					DPTR_staff_num INTEGER NOT NULL,
					DPTR_driver_departure_date DATE NOT NULL,
					PRIMARY KEY(Departure_num),
					CONSTRAINT DPTR_vehicle_code
							   FOREIGN KEY(Vehicle_code)
							   REFERENCES Vehicle(Vehicle_code)ON DELETE CASCADE);
							   
ALTER TABLE Departure
ADD CONSTRAINT DPTR_staff_number
               FOREIGN KEY(DPTR_staff_num)
			   REFERENCES Staff(Staff_num)ON DELETE CASCADE;
			  
begin
insert into Education_levels(EDCT_LVL_educational_background) values('Specialized medium');
insert into Education_levels(EDCT_LVL_educational_background) values('General average');
insert into Education_levels(EDCT_LVL_educational_background) values('Higher education');
end;
/

begin
insert into Manufacturers(MNF_name,MNF_office_address,MNF_ceo_phone) values('Volkswagen','Proyezd Kalvariyskiy 1, Minsk', '+375(44)141-12-12');
insert into Manufacturers(MNF_name,MNF_office_address,MNF_ceo_phone) values('Mercedes','Prospekte Pobeditelei 8, Minsk', '+375(44)331-33-12');
insert into Manufacturers(MNF_name,MNF_office_address,MNF_ceo_phone) values('Audi','Prospekte Pobeditelei 65, Minsk', '+375(44)531-23-12');
end;
/

begin
INSERT ALL
  INTO Positions VALUES (1, 'Employee', 1, 800, 'No', 'No', 'No')
  INTO Positions VALUES (2, 'Branch chief employee', 3, 1500, 'Yes', 'No', 'Yes')
  INTO Positions VALUES (3, 'Courier', 2, 1000, 'No', 'Yes', 'Yes')
  INTO Positions VALUES (4, 'Truck driver', 2, 900, 'No', 'Yes', 'No')
  INTO Positions VALUES (5, 'Branch network CEO', 3, 2000, 'Yes', 'No', 'Yes')
SELECT * FROM dual;
end;
/

begin
insert into Vehicles_sellers(SLR_phone) values('+375(29)132-15-12');
insert into Vehicles_sellers(SLR_phone) values('+375(44)135-16-96');
insert into Vehicles_sellers(SLR_phone) values('+375(44)123-12-53');
end;
/

begin
insert into Delivery_type(DLV_delivery_method) values('Courier');
insert into Delivery_type(DLV_delivery_method) values('Truck');
end;
/

begin
insert into Gearbox(GEAR_type) values('Automatic');
insert into Gearbox(GEAR_type) values('Mechanic');
end;
/

begin
insert into Branch(BR_max_storage_capacity,BR_principal_employee_name,BR_principal_employee_phone,BR_address,BR_employee_num,BR_ceo_director) values(20,'Zheldin A.A.','+375(25)542-35-11','Minsk, Chernyshevskogo street 20,3',4,16);
insert into Branch(BR_max_storage_capacity,BR_principal_employee_name,BR_principal_employee_phone,BR_address,BR_employee_num,BR_ceo_director) values(26,'Chernyak A.A.','+375(44)142-12-41','Minsk, 1 Berezova str.',4,16);
insert into Branch(BR_max_storage_capacity,BR_principal_employee_name,BR_principal_employee_phone,BR_address,BR_employee_num,BR_ceo_director) values(30,'Tikhonov F.P.','+375(25)008-70-12','Minsk, Jasminovaya str. 21',4,16);
insert into Branch(BR_max_storage_capacity,BR_principal_employee_name,BR_principal_employee_phone,BR_address,BR_employee_num,BR_ceo_director) values(100,'Medvedev A.F.','+375(44)533-22-12','Minsk, Domashnaya str. 22',3,16);
end;
/

begin
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Dedischev P.A.',DATE '2000-10-01','Minsk, Nezavisimosti Ave. 31,1',1,'dedishef2000@gmail.com','HB2331252',1,'+375(44)535-66-12');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Zheldin A.A.',DATE '1990-02-24','Minsk, Chernyshevskogo street 20,3',2,'zheldin1990@gmail.com','HB1208912',1,'+375(25)542-35-11');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Golubev D.V.',DATE '1978-02-01','Minsk, Manukevicha street 20,3',1,'golubeddddd@gmail.com','HB2304234',1,'+375(44)808-70-92');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Petrova V.A.',DATE '2002-01-02','Minsk, Petrusya Brovka str. 20,3',3,'petrova3212@gmail.com','HB1121242',1,'+375(25)112-44-12');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Lyadov O.V.',DATE '1990-02-27','Minsk, Leonida Beda str. 12,2',1,'lyyyaadov@gmail.com','HB1231001',2,'+375(44)110-09-97');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Markov V.V.',DATE '1988-02-14','Minsk, Bratskaya str. 20',1,'markov1988@gmail.com','HB2233332',2,'+375(25)444-22-11');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Chernyak A.A.',DATE '2000-10-20','Minsk, 1 Berezova str.',2,'chernyykkkk@gmail.com','HB0901232',2,'+375(44)142-12-41');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Kirikovsky Y.A.',DATE '1981-02-16','Minsk, Vostochnaya str. 11, 1',3,'kirikirikiri81@gmail.com','HB2309099',2,'+375(25)392-37-77');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Sokolov A.F.',DATE '1998-02-12','Minsk, Dachnaya str. 24,1',1,'sokosokolov@gmail.com','HB2304234',3,'+375(44)090-12-12');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Mikhailov D.V.',DATE '1988-10-24','Minsk, Yesenina str. 12,4',1,'mihhhhaylov@gmail.com','HB8084151',3,'+375(25)987-12-31');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Vasiliev D.D.',DATE '2001-11-01','Minsk, Yermaka str. 23',3,'vasssssssilyev@gmail.com','HB0801241',3,'+375(44)987-81-23');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Tikhonov F.P.',DATE '2000-02-25','Minsk, Jasminovaya str. 21',2,'tyhonov2000@gmail.com','HB8293412',3,'+375(25)008-70-12');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Medvedev A.F.',DATE '2001-01-16','Minsk, Domashnaya str. 22',2,'medveddddd@gmail.com','HB2080811',4,'+375(44)533-22-12');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Ponomarev A.V.',DATE '1994-02-24','Gomel, 1 Kuibysheva str.',1,'pono1994pon@gmail.com','HB8972342',4,'+375(25)119-99-00');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Shevchenko D.A.',DATE '1990-12-15','Minsk, Gvardeyskaya str. 34',3,'shEva2000@gmail.com','HB0808999',4,'+375(44)110-98-09');
insert into Staff(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) values('Zhmurkin S.A.',DATE '1989-01-14','Minsk, Pervomayskaya str. 12',5,'zhmurrrr89@gmail.com','HB8333123',4,'+375(44)097-80-91');
end;
/

begin
insert into VEHICLE(VIN,VHC_model,VHC_gear_code,VHC_manufact_code,VHC_max_load_capacity,VHC_release_year,VHC_inspection_date,VHC_seller_code) values('WBAGB330402182616','Caddy',1,1,1000,DATE '2005-10-24',DATE '2023-01-10',1);
insert into VEHICLE(VIN,VHC_model,VHC_gear_code,VHC_manufact_code,VHC_max_load_capacity,VHC_release_year,VHC_inspection_date,VHC_seller_code) values('WSDFB330423423422','Caddy',1,1,1000,DATE '2000-12-10',DATE '2023-01-13',1);
insert into VEHICLE(VIN,VHC_model,VHC_gear_code,VHC_manufact_code,VHC_max_load_capacity,VHC_release_year,VHC_inspection_date,VHC_seller_code) values('GAHDS234232325325','Caddy',1,1,1500,DATE '2010-11-12',DATE '2023-02-12',1);
insert into VEHICLE(VIN,VHC_model,VHC_gear_code,VHC_manufact_code,VHC_max_load_capacity,VHC_release_year,VHC_inspection_date,VHC_seller_code) values('DSFAW767357342311','Sprinter',1,2,3000,DATE '2012-05-23',DATE '2023-05-02',1);
end;
/

begin
insert into Departure(Vehicle_code,DPTR_sending_office_address,DPTR_staff_num,DPTR_driver_departure_date) values(1, 'Minsk, Chernyshevskogo street 20,3', 4, DATE '2023-03-31');
insert into Departure(Vehicle_code,DPTR_sending_office_address,DPTR_staff_num,DPTR_driver_departure_date) values(3, 'Minsk, Chernyshevskogo street 20,3', 4, DATE '2023-04-04');
insert into Departure(Vehicle_code,DPTR_sending_office_address,DPTR_staff_num,DPTR_driver_departure_date) values(4, 'Minsk, Chernyshevskogo street 20,3', 4, DATE '2023-04-20');
insert into Departure(Vehicle_code,DPTR_sending_office_address,DPTR_staff_num,DPTR_driver_departure_date) values(1, 'Minsk, Domashnaya str. 22', 8, DATE '2023-03-16');
end;
/

begin
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Arbuzov G.N.', 'Minsk, Pobediteley Ave. 47','+375(44)512-12-12',2,5,500,0.01,DATE '2023-03-30',20,50,'Yes','No',NULL,'Mishin P.P.','Vitebsk, Marochkina str. 23','+375(44)551-21-23',3,518.40,1,'Yes');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Meshkova U.U.','Minsk, Zvyozdnaya str. 21','+375(44)998-09-12',2,3,800,0.03,DATE '2023-03-29',40,60,'No','Yes',NULL,'Zhukov F.F.','Minsk, Zybitskaya str. 34','+375(44)333-98-71',2,345.60,2,'No');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Karginov F.V.','Minsk, Irkutskaya str. 10','+375(44)090-98-88',1,1,100,0.005,DATE '2023-03-30',10,20,'No','No',NULL,'Konyaev A.A.','Vitebsk, Korvata str. 53','+375(44)111-80-88',3,150.00,1,'No');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Zubayraev A.A.','Minsk, Izmailova str. 23','+375(44)123-11-11',1,1,800,0.01,DATE '2023-01-04',29,40,'No','Yes',NULL,'Suleymanov V.V.','Vitebsk, Severnaya str. 12','+375(44)123-11-21',3,172.80,1,'Yes');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Pavlovich T.I.','Minsk, 87 Karbysheva str.','+375(44)999-77-12',1,3,200,0.004,DATE '2023-04-04',40,50,'No','Yes',NULL,'Grishin A.K.','Minsk, Serova str. 81','+375(44)119-89-87',4,20.00,2,'Yes');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Semenchik T.A.','Minsk, 1 Kirov str.','+375(44)442-12-42',2,5,500,0.002,DATE '2023-03-10',100,2000,'No','No',NULL,'Petrov A.A.','Minsk 81 Michurinskaya str.','+375(44)111-22-31',3,86.40,1,'Yes');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Tishchenko F.F.','Minsk, 2, Kommunisticheskaya str.','+375(44)687-64-21',2,6,1000,0.001,DATE '2023-03-04',50,100,'Yes','No',NULL,'Kovalenko U.F.','Minsk, Zhemchuzhnaya str. 42','+375(44)982-17-20',3,172.80,2,'No');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Zhukov F.A.','Minsk, 12 Krylovicha str.','+375(44)522-12-15',2,5,400,0.001,DATE '2023-03-05',100,1000,'No','Yes',NULL,'Melnikov J.V.','Minsk 34, Kuleshova str.','+375(44)412-31-24',3,69.12,1,'No');
end;
/


begin
insert into Basket (Departure_num, Order_num) values(1,3);
insert into Basket (Departure_num, Order_num) values(2,5);
insert into Basket (Departure_num, Order_num) values(2,1);
insert into Basket (Departure_num, Order_num) values(3,2);
insert into Basket (Departure_num, Order_num) values(3,4);
insert into Basket (Departure_num, Order_num) values(3,6);
insert into Basket (Departure_num, Order_num) values(4,7);
end;
/

-----------------------------------SYNONYM-----------------------------------

//////TABLE AVTOMOBILI OF USER SYNONYM_WORKSPACE
CREATE TABLE AVTOMOBILI(avto INTEGER generated by default as identity(nocache),
                    avto_name VARCHAR2(25) NOT NULL,
                    PRIMARY KEY(avto));
				
begin
insert into AVTOMOBILI(avto_name) values('lamborghini');
insert into AVTOMOBILI(avto_name) values('porshe');
end;
/
				
GRANT SELECT ON AVTOMOBILI TO iosu_labki;
GRANT SELECT ON AVTOMOBILI TO iosu_labs;

//////

CREATE SYNONYM tachki for SYNONYM_WORKSPACE.AVTOMOBILI; 
CREATE SYNONYM tachki for SYSTEM.AVTOMOBILI; 


-----------------------------------INDEX-----------------------------------

CREATE INDEX STF_name_i 
ON Staff(STF_name);






++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Наиболее подходящими для индексации полями являются: поля внешних ключей; поля наиболее часто используемые в WHERE, GROUP BY, ORDER BY.

CACHE defines a number of values that Oracle should generate beforehand
to improve the performance. You use this option for the column that has 
a high number of inserts.

ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MM-YYYY';
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

------------------------CHECKING ALL INDEXES FOR A TABLE-----------------------------------------------------------
SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'STAFF';
-------------------------------------------------------------------------------------------------------------------

------------------------CHECKING CPU COSTS FOR SELECT OPERATION WITH INDEX-----------------------------------------
EXPLAIN PLAN FOR
SELECT * FROM STAFF
WHERE STF_name = 'Dedischev P.A.';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());
-------------------------------------------------------------------------------------------------------------------

-----------------------CHECKING CPU COSTS FOR SELECT OPERATION WITHOUT INDEX---------------------------------------
EXPLAIN PLAN FOR
SELECT * FROM VEHICLE
WHERE VHC_model = 'Caddy';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());

----------------------CHECKING CPU COSTS FOR SELECT OPERATION WITH INDEX
CREATE INDEX VHC_model_i 
ON Vehicle(VHC_model);

EXPLAIN PLAN FOR
SELECT * FROM VEHICLE
WHERE VHC_model = 'Caddy';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
------------------------------------------------------ЗАПРОСЫ------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------

3.1 УСЛОВНЫЙ:
отправители, входящие в первое отправление 

insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Maurice Wilson','Minsk, 15th Street to Parachute','+375(44)113-77-12',1,3,200,0.011,DATE '2023-09-12',44,50,'No','Yes',NULL,'Apa Sherpa','Minsk, 2 to Baikal Str','+375(44)120-89-87',4,25.00,2,'Yes');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Dorje Mingma','Minsk, 160 to East Street','+375(44)114-12-42',3,5,100,0.012,DATE '2023-09-10',23,400,'No','No',NULL,'Phurba Tashi Sherpa','Minsk, 2 to Starinovskaya Street','+375(44)121-22-31',2,96.40,1,'Yes');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Shao Shi-Ching','Minsk, 1-7 lane viaduct','+375(44)115-64-21',1,6,800,0.023,DATE '2023-09-09',520,1000,'Yes','No',NULL,'Dorje Gyalgen Sherpa','Minsk, 22 st to Tomsk','+375(44)122-17-20',3,12.80,2,'No');
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Jake Breitenbach','Minsk, 18 to the Koltsov Street','+375(44)116-12-15',2,5,900,0.021,DATE '2023-09-11',100,1000,'No','Yes',NULL,'Mingma Tsiri Sherpa','Minsk, 33 st to Baikal','+375(44)124-31-24',3,19.12,1,'No');

insert into Basket (Departure_num, Order_num) values(1,9);
insert into Basket (Departure_num, Order_num) values(1,10);
insert into Basket (Departure_num, Order_num) values(1,11);
insert into Basket (Departure_num, Order_num) values(1,12);

select basket.Departure_num, Orders.ORD_sender_name
from basket 
inner join Orders
on Basket.Order_num = Orders.Order_num and Basket.Departure_num = 1
order by 2; 

3.2 ИТОГОВЫЙ:
количество заказов на каждое отправление 

insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Lakpa Rita Sherpa','Minsk, 41 Draw a Street','+375(44)117-12-15',2,5,100,0.001,DATE '2023-09-11',104,300,'No','Yes',NULL,'Kenton Cool','Minsk, 43 st to Starobin','+375(44)126-31-24',3,10.12,1,'No');

insert into Departure(Vehicle_code,DPTR_sending_office_address,DPTR_staff_num,DPTR_driver_departure_date) values(3, 'Minsk, 6 to Krasnozvezdnaya Street', 4, DATE '2023-09-17');


insert into Basket (Departure_num, Order_num) values(5,13);

select basket.Departure_num, count(basket.order_num) orders_amount
from basket
group by basket.Departure_num
order by 1;

3.3 ПАРАМЕТРИЧЕСКИЙ:
заказы дешевле заданной стоимости

select orders.*
from orders
where orders.ORD_shipping_cost < &the_shipping_cost_limit
order by 1;

3.4 запрос на объединение.
вывести общий список отправителей и курьеров 

!!!!!!!!!!!!!!!!!!!нельзя понять, кто есть кто. нужно определять курьера и отправителя.
+ досчитать для отправителя кол-во отправленных посылок, а для курьера кол-во отправлений(доставленных)

select t1.sender_name, t1.orders_amount, t2.STF_name, t2.Departure_amount from 
(select orders.ORD_sender_name as sender_name, count(orders.order_num) as orders_amount
from orders 
group by orders.ORD_sender_name) t1
left outer join 
(select staff.STF_name, count(Departure.Departure_num) as Departure_amount
from staff 
inner join departure 
on staff.Staff_num = Departure.DPTR_staff_num
group by staff.STF_name) t2
on t2.Departure_amount >= 0;

------исправленный вариант
select t1.Courier_name as Person, t1.PST_name as role_name, departure_amount as departure_or_orders_amount from
(select distinct staff.STF_name as Courier_name, Positions.PST_name, count(Departure.Departure_num) as departure_amount
from Departure
inner join staff on Departure.DPTR_staff_num = staff.Staff_num 
inner join Positions on staff.STF_position_code = positions.Position_code
group by staff.STF_name,Positions.PST_name) t1
union select t2.ORD_sender_name,'Sender',t2.order_amount from
(select distinct orders.ORD_sender_name, count(orders.Order_num) as order_amount
from orders
group by ORD_sender_name) t2
order by role_name;
-------


3.5 итоговый запрос с использованием группировки по части поля с типом дата
суммарное количество заказов, оформленных по каждому дню, когда в целом были оформлены заказы
select ORD_package_receipt_date, count(order_num)
from orders 
group by ORD_package_receipt_date
order by 1;

суммарное количество отделений, оформлявших заказы по каждому дню, когда в целом были оформлены заказы

!!!!!!!!!!!!!!!!!!!!!!!!!!группировка по Части даты. какой день недели наиболее загруженный.

------исправленный вариант
select to_char(orders.ORD_package_receipt_date, 'D') as weekday, count(orders.order_num)
from orders
where to_char(orders.ORD_package_receipt_date, 'D') = '1'
group by to_char(orders.ORD_package_receipt_date, 'D') 
order by 1;

select to_char(orders.ORD_package_receipt_date, 'D') as weekday, count(orders.order_num)
from orders
group by to_char(orders.ORD_package_receipt_date, 'D') 
order by 1;

-------


select t1.ORD_package_receipt_date, count(Branch_num) from
(select distinct orders.ORD_package_receipt_date, branch.Branch_num
from branch
inner join orders
on branch.Branch_num = orders.ORD_sending_office) t1
group by t1.ORD_package_receipt_date
order by t1.ORD_package_receipt_date;

4.1	с внутренним соединением таблиц, используя стандартный синтаксис SQL (JOIN…ON, JOIN…USING или NATURAL JOIN), 
который не применялся в предыдущих запросах:

список сотрудников со списком номеров отделений, к которым эти сотрудники принадлежат

!!!!!!!!!!!!!!!!!!!!!!!! другой тип запроса

select branch.Branch_num, Staff.Staff_num, Staff.STF_name 
from branch
inner join Staff
on branch.Branch_num = staff.STF_branch_num
order by branch.Branch_num;

отправления, которые есть в basket, и для них выводим номер машины и адрес отделения
------исправленный вариант
select distinct departure.Vehicle_code, departure.DPTR_sending_office_address
from departure 
join basket 
using (departure_num)
order by 1;

select distinct departure_num, Vehicle_code, DPTR_sending_office_address
from departure d
join basket b
using (departure_num)
order by 1;
-------

количество авто, купленных компанией отделений у определенных дилеров - вывести список дилеров и кол-во купленных авто у каждого
select 

4.2 с внешним соединением таблиц, используя FULL JOIN, LEFT JOIN или RIGHT JOIN, при этом обязательным является наличие в 
БД данных, которые будут выводиться именно с выбранным оператором внешнего соединения

всевозможные типы кпп - присущие автомобилям в текущем автопарке

select gearbox.GEAR_type, Vehicle.VHC_model
from Gearbox
left outer join Vehicle
on gearbox.GEAR_code = vehicle.VHC_gear_code
order by 1;

4.3 с использованием предиката IN с подзапросом
вывести все должности, где необходимо высшее и среднее образование

select positions.PST_name
from positions
where positions.PST_min_level_of_education_code 
IN (select Education_levels.EDCT_LVL_code 
from Education_levels 
where Education_levels.EDCT_LVL_educational_background = 'Higher education' or Education_levels.EDCT_LVL_educational_background = 'General average');

4.4  с использованием предиката ANY/ALL с подзапросом

вывести всех сотрудников, чья зп больше чем средняя зп всех отделений

select t1.STF_name as employee_name, t1.PST_min_salary as salary from
(select staff.STF_name, positions.PST_min_salary
from Staff
inner join Positions
on staff.STF_position_code = positions.Position_code) t1
where t1.PST_min_salary > all(select avg(Positions.PST_min_salary)
from Staff
inner join Positions on staff.STF_position_code = positions.Position_code
inner join branch on staff.STF_branch_num = branch.Branch_num
group by branch.Branch_num);
----
select t1.STF_name as employee_name, t1.PST_min_salary as salary, t2.STF_branch_num as branch_num, t2.avg_salary as avg_salary from
(select staff.STF_name, positions.PST_min_salary, staff.STF_branch_num
from Staff
inner join Positions
on staff.STF_position_code = positions.Position_code) t1,
(select staff.STF_branch_num, avg(Positions.PST_min_salary) as avg_salary
from Staff
inner join Positions on staff.STF_position_code = positions.Position_code
inner join branch on staff.STF_branch_num = branch.Branch_num
group by staff.STF_branch_num) t2
where (t1.PST_min_salary > all t2.avg_salary) and t1.stf_branch_num = t2.STF_branch_num
order by 3;

4.5 с использованием предиката EXISTS/NOT EXISTS с подзапросом
вывести список работников, которые участвуют в процессе получения посылки от отправителя

select staff.STF_name from Staff
where exists (select 1 from Orders
where orders.ORD_employee_placing_the_order_num = staff.Staff_num);

2.Обновить одной командой информацию о максимальной рентной стоимости объектов, уменьшив стоимость квартир
на 5 %, а стоимость домов увеличив на 7 %.

Обновить одной командой информацию о зарплате сотрудников, уменьшив зарплату 
курьеров на 5 %, а зарплату работников увеличив на 7 %.

update Positions set PST_min_salary = 
case	
	when PST_name = 'Courier' then (PST_min_salary*0.95)
	when PST_name = 'Branch chief employee' then (PST_min_salary + PST_min_salary*0.07)
	when PST_name = 'Truck driver' then (PST_min_salary + PST_min_salary*0.07)
	when PST_name = 'Branch network CEO' then (PST_min_salary + PST_min_salary*0.07)
	when PST_name = 'Employee' then (PST_min_salary + PST_min_salary*0.07)
	when PST_name = 'Employee_second_category' then (PST_min_salary + PST_min_salary*0.07)
	when PST_name = 'Branch_chief_second_category' then (PST_min_salary + PST_min_salary*0.07)
end;
/

alter table Positions
drop column PST_min_salary;

alter table Positions
add PST_min_salary number(38,3);

update Positions
set PST_min_salary = 800.0
where Position_code = 1;

update Positions
set PST_min_salary = 1500.0
where Position_code = 2;

update Positions
set PST_min_salary = 1000.0
where Position_code = 3;

update Positions
set PST_min_salary = 900.0
where Position_code = 4;

update Positions
set PST_min_salary = 2000.0
where Position_code = 5;

###################################_3_LABA_#############################
2.1)	горизонтальное обновляемое представление с условием (WHERE)

create or replace view view2_first AS
select * from staff 
where staff.stf_position_code in
(select position_code from positions
where positions.pst_name = 'Courier' or positions.pst_name = 'Employee')
WITH CHECK OPTION;
------
create or replace view view2_first AS
select * from staff 
where staff.stf_position_code = 1 or staff.stf_position_code = 3
WITH CHECK OPTION;
------
2.2) проверить обновляемость горизонтального представления с фразой 
WITH CHECK OPTION при помощи одной из инструкций UPDATE, DELETE, INSERT 
(привести примеры выполняющихся и не выполняющихся инструкций, объяснить);

insert into view2_first(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) 
values('Shobic I.P.',DATE '2003-01-11','Minsk, Braginskiy 1',2,'Shobic2003@gmail.com','HB3433353',1,'+375(44)500-66-12');

insert into view2_first(STF_name,STF_birth_date,STF_address,STF_position_code,STF_email,STF_passport_details,STF_branch_num,STF_phone_num) 
values('Dvornic K.T.',DATE '2003-05-06','Minsk, Charota ul 1-59',1,'Dvornic2003@gmail.com','HB2252352',1,'+375(44)521-65-15');

2.3)Создать вертикальное или смешанное необновляемое представление, предназначенное для работы с основной таблицей 
БД (в представлении должны содержаться сведения из основной дочерней таблицы и/или корзины (если есть), но вместо 
внешних ключей использовать связанные данные родительских таблиц, понятные конечному пользователю представления);
2.4) доказать необновляемость представления из предыдущего пункта, проверив возможность 
выполнения инструкций UPDATE, DELETE, INSERT над представлением. Сохранить полученный результат 
(сообщение об ошибке или об успешном выполнении), объяснить причины;
create or replace view view2_third AS
select distinct orders.order_num as order_number,
orders.ORD_package_receipt_date,
orders.ord_sender_name as order_sender_name,
branch.BR_address as sending_office_address,
delivery_type.dlv_delivery_method as delivery_method,
staff.stf_name as placing_the_order_employee_name
from orders
inner join branch on orders.ORD_sending_office = branch.branch_num
inner join delivery_type on orders.ORD_deliv_type_code = delivery_type.DLV_code
inner join staff on orders.ORD_employee_placing_the_order_num = staff.Staff_num
where to_char(orders.ORD_package_receipt_date, 'MM') = '03';

select * from view2_third;

delete from view2_third
where order_number = 1;

2.5) cоздать обновляемое представление для работы с одной из родительских таблиц 
индивидуальной БД и через него разрешить работу с данными только в рабочие дни 
(с понедельника по пятницу) и в рабочие часы (с 9:00 до 17:00) с учетом часового пояса.

CREATE OR REPLACE VIEW view2_fifth AS
SELECT *
FROM staff
WHERE (TO_CHAR(SYSDATE, 'D') BETWEEN '1' AND '5')
  AND (TO_CHAR(SYSDATE, 'HH24:MI') BETWEEN '09:00' AND '17:00')
WITH CHECK OPTION;

select * from view2_fifth;

-------------------------------------------------------------------------------------------------------------------
---------------------------------------------4 LABA----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
set serveroutput on
 
1.	СОЗДАТЬ ПРОЦЕДУРУ.
____TASK____: ВЫВЕСТИ ВСЮ ИНФУ О РАБОТНИКЕ С ID = 1.
____CODE____:
create or replace procedure staff_info(in_staff_num number)
is
p_info staff%rowtype;
begin
select * into p_info
from staff
where staff_num = in_staff_num;

dbms_output.put_line(p_info.stf_name || '   ' ||
p_info.stf_birth_date || '   ' || p_info.stf_address || '   ' || p_info.stf_position_code || '   ' || 
p_info.stf_email || '   ' || p_info.stf_passport_details || '   ' || 
p_info.stf_branch_num || '   ' || p_info.stf_phone_num || '   ');

exception
	when others then
		dbms_output.put_line(SQLERRM);
END;
/
____TESTING____:
BEGIN
staff_info(1);
--EXECUTE staff_info(1);
end;
/
____END____.
2.	СОЗДАТЬ ФУНКЦИЮ.
____TASK____: посчитать возраст сотрудника с опредленным фио и вывести инфу о всех сотрудниках компании, которые старше этого сотрудника
____CODE____:
Dedischev P.A.
create or replace function get_staff_age(
	staff_name staff.STF_name%TYPE,
	dateval date default sysdate
)
return VARCHAR2	
is
result interval year to month;
s_birth_date staff.STF_birth_date%type;
begin
select STF_birth_date into s_birth_date from staff
where staff.STF_name = staff_name;
result := (dateval - s_birth_date) year to month;
return result;
end;
/ 
____TESTING____:
SELECT STF_name, stf_birth_date, get_staff_age (STF_name) 
FROM staff 
WHERE (sysdate - stf_birth_date) YEAR TO MONTH > get_staff_age ('Dedischev P.A.');
____END____.

3.1. Создать процедуру, копирующую строки с информацией о заказах за текущий месяц, 
во вспомогательную таблицу используя явный курсор или курсорную переменную, а также 
атрибуты курсора;

____TASK____: Создать процедуру в oracle, копирующую строки с информацией о заказах за текущий месяц, 
во вспомогательную таблицу используя явный курсор или курсорную переменную, а также атрибуты курсора, 
которая использует пакет DBMS_OUTPUT для вывода результатов работы в SQL*Plus, а также, которая 
предусматривает секцию обработки исключительных ситуаций, причем обязательно использовать как 
предустановленные исключительные ситуации, так и собственные (например, стоит 
контролировать наличие в БД значений, передаваемых в процедуры и функции как параметры.

обработка искл.ситуация будет заключаться в том, что если id заказа будет повторяться,
то будет появляться сообщение 

CREATE TABLE aux_table(aux_Order_num INTEGER CONSTRAINT aux_order_number UNIQUE,
					aux_ORD_sender_name VARCHAR2(40) NOT NULL,
					aux_ORD_sender_address VARCHAR2(50) NOT NULL,
					aux_ORD_sender_phone CHAR(17) NOT NULL,
					aux_ORD_sending_office VARCHAR2(255) NOT NULL,
					aux_ORD_employee_placing_the_order_num VARCHAR2(255) NOT NULL,
					aux_ORD_package_weight DECIMAL(20,3) NOT NULL,
					aux_ORD_package_scope DECIMAL(20,3) NOT NULL,
					aux_ORD_package_receipt_date DATE NOT NULL,
					aux_ORD_declared_value_amount DECIMAL(30,3),
					aux_ORD_cash_on_dlvry_amount DECIMAL(30,3),
					aux_ORD_fragile VARCHAR2(3) NOT NULL,
					aux_ORD_completeness_check VARCHAR2(3) NOT NULL,
                    aux_ORD_arrival_date DATE,
					aux_ORD_recipient_name VARCHAR2(40) NOT NULL,
					aux_ORD_recipient_address VARCHAR2(50) NOT NULL,
					aux_ORD_recipient_phone CHAR(17) NOT NULL,
					aux_ORD_receiving_office VARCHAR2(255) NOT NULL,
					aux_ORD_shipping_cost DECIMAL(30,3) NOT NULL,
					aux_ORD_deliv_type_code VARCHAR2(255) NOT NULL,
					aux_ORD_cash_payment VARCHAR2(3) NOT NULL,
					aux_ORD_SENDER_BIRTH_DAY DATE,
					aux_ORD_PICKED_UP_DATE TIMESTAMP(6) ,
					aux_ORD_PICKED_UP VARCHAR2(3) ,
					aux_ONLY_SENDER_NAME VARCHAR2(50) ,
					aux_ONLY_SENDER_SURNAME VARCHAR2(50),
					aux_ONLY_SENDER_PATRONYMIC VARCHAR2(50)
);

CREATE OR REPLACE PROCEDURE copy_orders_to_aux_table
AS
	cursor orders_cursor is
	select * 
	from orders 
	where ORD_package_receipt_date BETWEEN TRUNC(SYSDATE, 'MONTH') AND SYSDATE;
			
	p_Order_num INTEGER;
	p_ORD_sender_name VARCHAR2(40);
	p_ORD_sender_address VARCHAR2(50);
	p_ORD_sender_phone CHAR(17);
	p_ORD_sending_office VARCHAR2(255);
	p_ORD_employee_placing_the_order_num VARCHAR2(255);
	p_ORD_package_weight DECIMAL(20,3);
	p_ORD_package_scope DECIMAL(20,3);
	p_ORD_package_receipt_date DATE;
	p_ORD_declared_value_amount DECIMAL(30,3);
	p_ORD_cash_on_dlvry_amount DECIMAL(30,3);
	p_ORD_fragile VARCHAR2(3);
	p_ORD_completeness_check VARCHAR2(3);
	p_ORD_arrival_date DATE;
	p_ORD_recipient_name VARCHAR2(40);
	p_ORD_recipient_address VARCHAR2(50);
	p_ORD_recipient_phone CHAR(17);
	p_ORD_receiving_office VARCHAR2(255);
	p_ORD_shipping_cost DECIMAL(30,3);
	p_ORD_deliv_type_code VARCHAR2(255);
	p_ORD_cash_payment VARCHAR2(3);	
	p_ORD_SENDER_BIRTH_DAY DATE;
	p_ORD_PICKED_UP_DATE TIMESTAMP(6);
	p_ORD_PICKED_UP VARCHAR2(3);
	p_ONLY_SENDER_NAME VARCHAR2(50);
	p_ONLY_SENDER_SURNAME VARCHAR2(50);
	p_ONLY_SENDER_PATRONYMIC VARCHAR2(50);

	
	exp_unique_id exception;
	PRAGMA EXCEPTION_INIT (exp_unique_id, -00001);

begin

	OPEN orders_cursor;
	
	--OPEN orders_cursor;

	loop 
	begin
		fetch orders_cursor into p_Order_num,p_ORD_sender_name,
		p_ORD_sender_address,p_ORD_sender_phone,p_ORD_sending_office,
		p_ORD_employee_placing_the_order_num,p_ORD_package_weight,
		p_ORD_package_scope,p_ORD_package_receipt_date,
		p_ORD_declared_value_amount,p_ORD_cash_on_dlvry_amount,
		p_ORD_fragile,p_ORD_completeness_check,p_ORD_arrival_date,
		p_ORD_recipient_name,p_ORD_recipient_address,
		p_ORD_recipient_phone,p_ORD_receiving_office,p_ORD_shipping_cost,
		p_ORD_deliv_type_code,p_ORD_cash_payment, p_ORD_SENDER_BIRTH_DAY, 
		p_ORD_PICKED_UP_DATE, p_ORD_PICKED_UP, p_ONLY_SENDER_NAME, p_ONLY_SENDER_SURNAME,
		p_ONLY_SENDER_PATRONYMIC;
		
		exit when orders_cursor%NOTFOUND;
		
		
		insert into aux_table(aux_Order_num,aux_ORD_sender_name,
		aux_ORD_sender_address,aux_ORD_sender_phone,aux_ORD_sending_office,
		aux_ORD_employee_placing_the_order_num,aux_ORD_package_weight,
		aux_ORD_package_scope,aux_ORD_package_receipt_date,
		aux_ORD_declared_value_amount,aux_ORD_cash_on_dlvry_amount,
		aux_ORD_fragile,aux_ORD_completeness_check,aux_ORD_arrival_date,
		aux_ORD_recipient_name,aux_ORD_recipient_address,
		aux_ORD_recipient_phone,aux_ORD_receiving_office,
		aux_ORD_shipping_cost,aux_ORD_deliv_type_code,aux_ORD_cash_payment, aux_ORD_SENDER_BIRTH_DAY, 
		aux_ORD_PICKED_UP_DATE, aux_ORD_PICKED_UP, aux_ONLY_SENDER_NAME, aux_ONLY_SENDER_SURNAME, 
		aux_ONLY_SENDER_PATRONYMIC)
		values (p_Order_num, p_ORD_sender_name, p_ORD_sender_address,
		p_ORD_sender_phone,	p_ORD_sending_office, p_ORD_employee_placing_the_order_num,
		p_ORD_package_weight, p_ORD_package_scope, p_ORD_package_receipt_date, 
		p_ORD_declared_value_amount, p_ORD_cash_on_dlvry_amount, 
		p_ORD_fragile, p_ORD_completeness_check,p_ORD_arrival_date, 
		p_ORD_recipient_name, p_ORD_recipient_address, p_ORD_recipient_phone, 
		p_ORD_receiving_office,	p_ORD_shipping_cost, p_ORD_deliv_type_code, 
		p_ORD_cash_payment, p_ORD_SENDER_BIRTH_DAY, p_ORD_PICKED_UP_DATE, p_ORD_PICKED_UP, p_ONLY_SENDER_NAME, p_ONLY_SENDER_SURNAME,
		p_ONLY_SENDER_PATRONYMIC);
				
		exception
		WHEN exp_unique_id THEN
		DBMS_OUTPUT.PUT_LINE ('Ошибка №' || sqlcode || ' заказ с номером ' || p_Order_num || ' уже существует'); 
		when others then 
		DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);

	end;

	end loop;
		
		close orders_cursor;
		
		update aux_table
		set aux_ORD_sending_office = (
		  select (to_char(BR_max_storage_capacity) || ' ' || BR_principal_employee_name || ' ' || BR_principal_employee_phone || ' ' || BR_address || ' ' || to_char(BR_employee_num) || ' ' || to_char(BR_ceo_director))
		  from branch
		  where branch.branch_num = to_number(aux_table.aux_ORD_sending_office) and VALIDATE_CONVERSION(aux_table.aux_ORD_sending_office as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_sending_office as NUMBER) = 1;	
		
		update aux_table
		set aux_ORD_employee_placing_the_order_num = (
		  select (STF_name || ' ' || STF_birth_date || ' ' || STF_address || ' ' || to_char(STF_position_code) || ' ' || STF_email || ' ' || STF_passport_details || ' ' || to_char(STF_branch_num) || ' ' ||  STF_phone_num)
		  from staff
		  where staff.Staff_num = to_number(aux_table.aux_ORD_employee_placing_the_order_num) and VALIDATE_CONVERSION(aux_table.aux_ORD_employee_placing_the_order_num as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_employee_placing_the_order_num as NUMBER) = 1;	

		update aux_table
		set aux_ORD_receiving_office = (
		  select (to_char(BR_max_storage_capacity) || ' ' || BR_principal_employee_name || ' ' || BR_principal_employee_phone || ' ' || BR_address || ' ' || to_char(BR_employee_num) || ' ' || to_char(BR_ceo_director))
		  from branch
		  where branch.branch_num = to_number(aux_table.aux_ORD_receiving_office) and VALIDATE_CONVERSION(aux_table.aux_ORD_receiving_office as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_receiving_office as NUMBER) = 1;	

		update aux_table
		set aux_ORD_deliv_type_code = (
		  select DLV_delivery_method
		  from Delivery_type
		  where Delivery_type.DLV_code = to_number(aux_table.aux_ORD_deliv_type_code) and VALIDATE_CONVERSION(aux_table.aux_ORD_deliv_type_code as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_deliv_type_code as NUMBER) = 1;	

		DBMS_OUTPUT.PUT_LINE('The lines have been copied successfully');
	
exception
	WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('За текущий месяцев не было сделано ни одного заказа');
	WHEN CURSOR_ALREADY_OPEN THEN
    DBMS_OUTPUT.PUT_LINE('Ошибка №' || sqlcode || '. Курсор уже открыт');
	when others then 
    DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);

END;
/
-------------------------------------------------------------------------------------------------------------------
____TESTING____:
begin
EXECUTE copy_orders_to_aux_table;
END;
/
____END____.

3.2. ____TASK____: Написать функцию, которая выводит информацию о отправителях, которые оформили 
количество заказов за указанный год больше, чем указано во входном параметре. 
Возвращать общее количество подписчиков. 
	используя явный курсор или курсорную переменную, а также атрибуты курсора;
	используя пакет DBMS_OUTPUT для вывода результатов работы в SQL*Plus;
	предусмотреть секцию обработки исключительных ситуаций, причем обязательно использовать как предустановленные 
исключительные ситуации, так и собственные (например, стоит контролировать наличие в БД значений, передаваемых в процедуры и функции как параметры
____CODE____:
CREATE OR REPLACE FUNCTION subscribers_with_more_subscriptions(year IN NUMBER, threshold IN NUMBER) RETURN NUMBER IS
   CURSOR subscriber_cursor IS
      SELECT ORD_sender_name, ORD_sender_address, ORD_sender_phone, COUNT(order_num) AS orders_count
      FROM orders
      WHERE EXTRACT(YEAR FROM ORD_package_receipt_date) = year
      GROUP BY ORD_sender_name, ORD_sender_address, ORD_sender_phone
      HAVING COUNT(order_num) > threshold;
	  
	f_ORD_sender_name VARCHAR2(40);
	f_ORD_sender_address VARCHAR2(50);
	f_ORD_sender_phone CHAR(17);
	orders_count NUMBER;
	total_subscribers NUMBER := 0;

	correct_year exception;
	PRAGMA EXCEPTION_INIT (correct_year, -20001);

	correct_threshold exception;
	PRAGMA EXCEPTION_INIT (correct_threshold, -20002);

BEGIN

	IF year > EXTRACT(YEAR FROM sysdate) THEN
		RAISE_APPLICATION_ERROR(-20001, 'Неверный год: ' || year);
	END IF;
	
	IF threshold < 0 THEN
		RAISE_APPLICATION_ERROR(-20002, 'Пороговое значение заказов должно быть больше 0');
	END IF;

	-- если не открыть курсор, то будет внутренняя ошибка с номером ORA-01001 INVALID_CURSOR
    OPEN subscriber_cursor;


    -- Перебираем результаты курсора
    LOOP
        FETCH subscriber_cursor INTO f_ORD_sender_name, f_ORD_sender_address, f_ORD_sender_phone, orders_count;
        EXIT WHEN subscriber_cursor%NOTFOUND;

        -- Выводим результаты в SQL*Plus
        DBMS_OUTPUT.PUT_LINE(
            'Имя отправителя: ' || f_ORD_sender_name ||
            ', Адрес отправителя: ' || f_ORD_sender_address ||
            ', Телефон отправителя: ' || f_ORD_sender_phone ||
            ', количество заказов: ' || orders_count);

        -- Увеличиваем счетчик общего количества подписчиков
        total_subscribers := total_subscribers + 1;

    END LOOP;

    -- Закрываем курсор
    CLOSE subscriber_cursor;

    -- Возвращаем общее количество подписчиков
    RETURN total_subscribers;
EXCEPTION
    WHEN correct_year THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN correct_threshold THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('В таблице orders нет данных за указанный год.');
	when INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('Вы не корректно работаете с курсором');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLCODE || ' - ' || SQLERRM);   
END;
/
---------------------------------------------------
____TESTING____:
DECLARE
    total_subscribers NUMBER;
BEGIN
    total_subscribers := subscribers_with_more_subscriptions(2023, 0);
    DBMS_OUTPUT.PUT_LINE('Количество подписчиков, оформивших хоть какое-то кол-во заказов за год 2023: ' || total_subscribers);
END;
/
____END____.

3.3.	
____TASK____: 
Создать локальную программу, изменив код ранее написанной процедуры или функции
____CODE____:
CREATE OR REPLACE FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN NUMBER) RETURN NUMBER IS
   CURSOR subscriber_cursor IS
      SELECT ORD_sender_name, ORD_sender_address, ORD_sender_phone, COUNT(order_num) AS orders_count
      FROM orders
      WHERE EXTRACT(YEAR FROM ORD_package_receipt_date) = year
      GROUP BY ORD_sender_name, ORD_sender_address, ORD_sender_phone
      HAVING COUNT(order_num) > threshold;
	  
	f_ORD_sender_name VARCHAR2(40);
	f_ORD_sender_address VARCHAR2(50);
	f_ORD_sender_phone CHAR(17);
	orders_count NUMBER;
	total_subscribers NUMBER := 0;
	
	correct_year exception;
	PRAGMA EXCEPTION_INIT (correct_year, -20001);

	correct_threshold exception;
	PRAGMA EXCEPTION_INIT (correct_threshold, -20002);
	
	FUNCTION correct_year_checking (year in Number)
	return Number
	IS
	result Number := 0;
	BEGIN
	IF year > EXTRACT(YEAR FROM sysdate) THEN
	result := 1;
	END IF;
	RETURN result;
	END correct_year_checking;

BEGIN	
	if correct_year_checking(year) = 1 then	
	RAISE_APPLICATION_ERROR(-20001, 'Неверный год: ' || year);
	end if;
	
	IF threshold < 0 THEN
		RAISE_APPLICATION_ERROR(-20002, 'Пороговое значение заказов должно быть больше 0');
	END IF;

	-- если не открыть курсор, то будет внутренняя ошибка с номером ORA-01001 INVALID_CURSOR
    OPEN subscriber_cursor;


    -- Перебираем результаты курсора
    LOOP
        FETCH subscriber_cursor INTO f_ORD_sender_name, f_ORD_sender_address, f_ORD_sender_phone, orders_count;
        EXIT WHEN subscriber_cursor%NOTFOUND;

        -- Выводим результаты в SQL*Plus
        DBMS_OUTPUT.PUT_LINE(
            'Имя отправителя: ' || f_ORD_sender_name ||
            ', Адрес отправителя: ' || f_ORD_sender_address ||
            ', Телефон отправителя: ' || f_ORD_sender_phone ||
            ', количество заказов: ' || orders_count);

        -- Увеличиваем счетчик общего количества подписчиков
        total_subscribers := total_subscribers + 1;

    END LOOP;

    -- Закрываем курсор
    CLOSE subscriber_cursor;

    -- Возвращаем общее количество подписчиков
    RETURN total_subscribers;
EXCEPTION
    WHEN correct_year THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN correct_threshold THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('В таблице orders нет данных за указанный год.');
	when INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('Вы не корректно работаете с курсором');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLCODE || ' - ' || SQLERRM);   
END;
/
---------------------------------------------------
____TESTING____:
DECLARE
    total_subscribers NUMBER;
BEGIN
    total_subscribers := local_subscribers_with_more_subscriptions(2022, 0);
    DBMS_OUTPUT.PUT_LINE('Количество подписчиков, оформивших хоть какое-то кол-во заказов за год 2022: ' || total_subscribers);
END;
/
____END____.
4.	
____TASK____: 
Написать перегруженные программы, используя для этого ранее созданную процедуру или функцию.
____CODE____:
DECLARE
threshold_num   VARCHAR2 (50) := '1';
threshold_varchar   NUMBER := 1;
total_subscribers NUMBER;

   
	FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN NUMBER) RETURN NUMBER IS
   CURSOR subscriber_cursor IS
      SELECT ORD_sender_name, ORD_sender_address, ORD_sender_phone, COUNT(order_num) AS orders_count
      FROM orders
      WHERE EXTRACT(YEAR FROM ORD_package_receipt_date) = year
      GROUP BY ORD_sender_name, ORD_sender_address, ORD_sender_phone
      HAVING COUNT(order_num) > threshold;
	  
	f_ORD_sender_name VARCHAR2(40);
	f_ORD_sender_address VARCHAR2(50);
	f_ORD_sender_phone CHAR(17);
	orders_count NUMBER;
	total_subscribers NUMBER := 0;
	
	correct_year exception;
	PRAGMA EXCEPTION_INIT (correct_year, -20001);

	correct_threshold exception;
	PRAGMA EXCEPTION_INIT (correct_threshold, -20002);
	
	FUNCTION correct_year_checking (year in Number)
	return Number
	IS
	result Number := 0;
	BEGIN
	IF year > EXTRACT(YEAR FROM sysdate) THEN
	result := 1;
	END IF;
	RETURN result;
	END correct_year_checking;

BEGIN	
	if correct_year_checking(year) = 1 then	
	RAISE_APPLICATION_ERROR(-20001, 'Неверный год: ' || year);
	end if;
	
	IF threshold < 0 THEN
		RAISE_APPLICATION_ERROR(-20002, 'Пороговое значение заказов должно быть больше 0');
	END IF;

	-- если не открыть курсор, то будет внутренняя ошибка с номером ORA-01001 INVALID_CURSOR
    OPEN subscriber_cursor;


    -- Перебираем результаты курсора
    LOOP
        FETCH subscriber_cursor INTO f_ORD_sender_name, f_ORD_sender_address, f_ORD_sender_phone, orders_count;
        EXIT WHEN subscriber_cursor%NOTFOUND;

        -- Выводим результаты в SQL*Plus
        DBMS_OUTPUT.PUT_LINE(
            'Имя отправителя: ' || f_ORD_sender_name ||
            ', Адрес отправителя: ' || f_ORD_sender_address ||
            ', Телефон отправителя: ' || f_ORD_sender_phone ||
            ', количество заказов: ' || orders_count);

        -- Увеличиваем счетчик общего количества подписчиков
        total_subscribers := total_subscribers + 1;

    END LOOP;

    -- Закрываем курсор
    CLOSE subscriber_cursor;

    -- Возвращаем общее количество подписчиков
    RETURN total_subscribers;
EXCEPTION
    WHEN correct_year THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN correct_threshold THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('В таблице orders нет данных за указанный год.');
	when INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('Вы не корректно работаете с курсором');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLCODE || ' - ' || SQLERRM);   
END;

	FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN VARCHAR2) RETURN NUMBER IS
   CURSOR subscriber_cursor IS
      SELECT ORD_sender_name, ORD_sender_address, ORD_sender_phone, COUNT(order_num) AS orders_count
      FROM orders
      WHERE EXTRACT(YEAR FROM ORD_package_receipt_date) = year
      GROUP BY ORD_sender_name, ORD_sender_address, ORD_sender_phone
      HAVING COUNT(order_num) > threshold;
	  
	threshold_num Number;
	f_ORD_sender_name VARCHAR2(40);
	f_ORD_sender_address VARCHAR2(50);
	f_ORD_sender_phone CHAR(17);
	orders_count NUMBER;
	total_subscribers NUMBER := 0;
		
	correct_year exception;
	PRAGMA EXCEPTION_INIT (correct_year, -20001);

	correct_threshold exception;
	PRAGMA EXCEPTION_INIT (correct_threshold, -20002);
	
	FUNCTION correct_year_checking (year in Number)
	return Number
	IS
	result Number := 0;
	BEGIN
	IF year > EXTRACT(YEAR FROM sysdate) THEN
	result := 1;
	END IF;
	RETURN result;
	END correct_year_checking;

BEGIN	
	threshold_num := TO_NUMBER(threshold);

	if correct_year_checking(year) = 1 then	
	RAISE_APPLICATION_ERROR(-20001, 'Неверный год: ' || year);
	end if;
	
	IF threshold < 0 THEN
		RAISE_APPLICATION_ERROR(-20002, 'Пороговое значение заказов должно быть больше 0');
	END IF;

	-- если не открыть курсор, то будет внутренняя ошибка с номером ORA-01001 INVALID_CURSOR
    OPEN subscriber_cursor;


    -- Перебираем результаты курсора
    LOOP
        FETCH subscriber_cursor INTO f_ORD_sender_name, f_ORD_sender_address, f_ORD_sender_phone, orders_count;
        EXIT WHEN subscriber_cursor%NOTFOUND;

        -- Выводим результаты в SQL*Plus
        DBMS_OUTPUT.PUT_LINE(
            'Имя отправителя: ' || f_ORD_sender_name ||
            ', Адрес отправителя: ' || f_ORD_sender_address ||
            ', Телефон отправителя: ' || f_ORD_sender_phone ||
            ', количество заказов: ' || orders_count);

        -- Увеличиваем счетчик общего количества подписчиков
        total_subscribers := total_subscribers + 1;

    END LOOP;

    -- Закрываем курсор
    CLOSE subscriber_cursor;

    -- Возвращаем общее количество подписчиков
    RETURN total_subscribers;
EXCEPTION
    WHEN correct_year THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN correct_threshold THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('В таблице orders нет данных за указанный год.');
	when INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('Вы не корректно работаете с курсором');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLCODE || ' - ' || SQLERRM);   
END;

BEGIN
    total_subscribers := local_subscribers_with_more_subscriptions(2022, threshold_num);
	total_subscribers := local_subscribers_with_more_subscriptions(2022, threshold_varchar);
END;
/
____TESTING____:
____END____.
5.	
____TASK____: 
Объединить все процедуры и функции, в том числе перегруженные, в пакет.
____CODE____:
CREATE OR REPLACE PACKAGE my_package IS

PROCEDURE copy_orders_to_aux_table;

FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN NUMBER) RETURN NUMBER;

FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN VARCHAR2) RETURN NUMBER ;
PRAGMA RESTRICT_REFERENCES (local_subscribers_with_more_subscriptions, WNDS);

END my_package;
/

CREATE OR REPLACE PACKAGE BODY my_package IS

PROCEDURE copy_orders_to_aux_table
AS
	cursor orders_cursor is
	select * 
	from orders 
	where ORD_package_receipt_date BETWEEN TRUNC(SYSDATE, 'MONTH') AND SYSDATE;
			
	p_Order_num INTEGER;
	p_ORD_sender_name VARCHAR2(40);
	p_ORD_sender_address VARCHAR2(50);
	p_ORD_sender_phone CHAR(17);
	p_ORD_sending_office VARCHAR2(255);
	p_ORD_employee_placing_the_order_num VARCHAR2(255);
	p_ORD_package_weight DECIMAL(20,3);
	p_ORD_package_scope DECIMAL(20,3);
	p_ORD_package_receipt_date DATE;
	p_ORD_declared_value_amount DECIMAL(30,3);
	p_ORD_cash_on_dlvry_amount DECIMAL(30,3);
	p_ORD_fragile VARCHAR2(3);
	p_ORD_completeness_check VARCHAR2(3);
	p_ORD_arrival_date DATE;
	p_ORD_recipient_name VARCHAR2(40);
	p_ORD_recipient_address VARCHAR2(50);
	p_ORD_recipient_phone CHAR(17);
	p_ORD_receiving_office VARCHAR2(255);
	p_ORD_shipping_cost DECIMAL(30,3);
	p_ORD_deliv_type_code VARCHAR2(255);
	p_ORD_cash_payment VARCHAR2(3);	
	p_ORD_SENDER_BIRTH_DAY DATE;
	p_ORD_PICKED_UP_DATE TIMESTAMP(6);
	p_ORD_PICKED_UP VARCHAR2(3);
	p_ONLY_SENDER_NAME VARCHAR2(50);
	p_ONLY_SENDER_SURNAME VARCHAR2(50);
	p_ONLY_SENDER_PATRONYMIC VARCHAR2(50);
	
	exp_unique_id exception;
	PRAGMA EXCEPTION_INIT (exp_unique_id, -00001);

begin

	OPEN orders_cursor;
	
	--OPEN orders_cursor;

	loop 
	begin
		fetch orders_cursor into p_Order_num,p_ORD_sender_name,
		p_ORD_sender_address,p_ORD_sender_phone,p_ORD_sending_office,
		p_ORD_employee_placing_the_order_num,p_ORD_package_weight,
		p_ORD_package_scope,p_ORD_package_receipt_date,
		p_ORD_declared_value_amount,p_ORD_cash_on_dlvry_amount,
		p_ORD_fragile,p_ORD_completeness_check,p_ORD_arrival_date,
		p_ORD_recipient_name,p_ORD_recipient_address,
		p_ORD_recipient_phone,p_ORD_receiving_office,p_ORD_shipping_cost,
		p_ORD_deliv_type_code,p_ORD_cash_payment, p_ORD_SENDER_BIRTH_DAY, 
		p_ORD_PICKED_UP_DATE, p_ORD_PICKED_UP, p_ONLY_SENDER_NAME, p_ONLY_SENDER_SURNAME,
		p_ONLY_SENDER_PATRONYMIC;
		
		exit when orders_cursor%NOTFOUND;
		
		
		insert into aux_table(aux_Order_num,aux_ORD_sender_name,
		aux_ORD_sender_address,aux_ORD_sender_phone,aux_ORD_sending_office,
		aux_ORD_employee_placing_the_order_num,aux_ORD_package_weight,
		aux_ORD_package_scope,aux_ORD_package_receipt_date,
		aux_ORD_declared_value_amount,aux_ORD_cash_on_dlvry_amount,
		aux_ORD_fragile,aux_ORD_completeness_check,aux_ORD_arrival_date,
		aux_ORD_recipient_name,aux_ORD_recipient_address,
		aux_ORD_recipient_phone,aux_ORD_receiving_office,
		aux_ORD_shipping_cost,aux_ORD_deliv_type_code,aux_ORD_cash_payment, aux_ORD_SENDER_BIRTH_DAY, 
		aux_ORD_PICKED_UP_DATE, aux_ORD_PICKED_UP, aux_ONLY_SENDER_NAME, aux_ONLY_SENDER_SURNAME, 
		aux_ONLY_SENDER_PATRONYMIC)
		values (p_Order_num, p_ORD_sender_name, p_ORD_sender_address,
		p_ORD_sender_phone,	p_ORD_sending_office, p_ORD_employee_placing_the_order_num,
		p_ORD_package_weight, p_ORD_package_scope, p_ORD_package_receipt_date, 
		p_ORD_declared_value_amount, p_ORD_cash_on_dlvry_amount, 
		p_ORD_fragile, p_ORD_completeness_check,p_ORD_arrival_date, 
		p_ORD_recipient_name, p_ORD_recipient_address, p_ORD_recipient_phone, 
		p_ORD_receiving_office,	p_ORD_shipping_cost, p_ORD_deliv_type_code, 
		p_ORD_cash_payment, p_ORD_SENDER_BIRTH_DAY, p_ORD_PICKED_UP_DATE, p_ORD_PICKED_UP, p_ONLY_SENDER_NAME, p_ONLY_SENDER_SURNAME,
		p_ONLY_SENDER_PATRONYMIC);
				
		exception
		WHEN exp_unique_id THEN
		DBMS_OUTPUT.PUT_LINE ('Ошибка №' || sqlcode || ' заказ с номером ' || p_Order_num || ' уже существует'); 
		when others then 
		DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);

	end;

	end loop;
		
		close orders_cursor;
		
		update aux_table
		set aux_ORD_sending_office = (
		  select (to_char(BR_max_storage_capacity) || ' ' || BR_principal_employee_name || ' ' || BR_principal_employee_phone || ' ' || BR_address || ' ' || to_char(BR_employee_num) || ' ' || to_char(BR_ceo_director))
		  from branch
		  where branch.branch_num = to_number(aux_table.aux_ORD_sending_office) and VALIDATE_CONVERSION(aux_table.aux_ORD_sending_office as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_sending_office as NUMBER) = 1;	
		
		update aux_table
		set aux_ORD_employee_placing_the_order_num = (
		  select (STF_name || ' ' || STF_birth_date || ' ' || STF_address || ' ' || to_char(STF_position_code) || ' ' || STF_email || ' ' || STF_passport_details || ' ' || to_char(STF_branch_num) || ' ' ||  STF_phone_num)
		  from staff
		  where staff.Staff_num = to_number(aux_table.aux_ORD_employee_placing_the_order_num) and VALIDATE_CONVERSION(aux_table.aux_ORD_employee_placing_the_order_num as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_employee_placing_the_order_num as NUMBER) = 1;	

		update aux_table
		set aux_ORD_receiving_office = (
		  select (to_char(BR_max_storage_capacity) || ' ' || BR_principal_employee_name || ' ' || BR_principal_employee_phone || ' ' || BR_address || ' ' || to_char(BR_employee_num) || ' ' || to_char(BR_ceo_director))
		  from branch
		  where branch.branch_num = to_number(aux_table.aux_ORD_receiving_office) and VALIDATE_CONVERSION(aux_table.aux_ORD_receiving_office as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_receiving_office as NUMBER) = 1;	

		update aux_table
		set aux_ORD_deliv_type_code = (
		  select DLV_delivery_method
		  from Delivery_type
		  where Delivery_type.DLV_code = to_number(aux_table.aux_ORD_deliv_type_code) and VALIDATE_CONVERSION(aux_table.aux_ORD_deliv_type_code as NUMBER) = 1
		) where VALIDATE_CONVERSION(aux_ORD_deliv_type_code as NUMBER) = 1;	

		DBMS_OUTPUT.PUT_LINE('The lines have been copied successfully');
	
exception
	WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('За текущий месяцев не было сделано ни одного заказа');
	WHEN CURSOR_ALREADY_OPEN THEN
    DBMS_OUTPUT.PUT_LINE('Ошибка №' || sqlcode || '. Курсор уже открыт');
	when others then 
    DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);

END copy_orders_to_aux_table;

FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN NUMBER) RETURN NUMBER IS
   CURSOR subscriber_cursor IS
      SELECT ORD_sender_name, ORD_sender_address, ORD_sender_phone, COUNT(order_num) AS orders_count
      FROM orders
      WHERE EXTRACT(YEAR FROM ORD_package_receipt_date) = year
      GROUP BY ORD_sender_name, ORD_sender_address, ORD_sender_phone
      HAVING COUNT(order_num) > threshold;
	  
	f_ORD_sender_name VARCHAR2(40);
	f_ORD_sender_address VARCHAR2(50);
	f_ORD_sender_phone CHAR(17);
	orders_count NUMBER;
	total_subscribers NUMBER := 0;
	
	correct_year exception;
	PRAGMA EXCEPTION_INIT (correct_year, -20001);

	correct_threshold exception;
	PRAGMA EXCEPTION_INIT (correct_threshold, -20002);
	
	FUNCTION correct_year_checking (year in Number)
	return Number
	IS
	result Number := 0;
	BEGIN
	IF year > EXTRACT(YEAR FROM sysdate) THEN
	result := 1;
	END IF;
	RETURN result;
	END correct_year_checking;

BEGIN	
	if correct_year_checking(year) = 1 then	
	RAISE_APPLICATION_ERROR(-20001, 'Неверный год: ' || year);
	end if;
	
	IF threshold < 0 THEN
		RAISE_APPLICATION_ERROR(-20002, 'Пороговое значение заказов должно быть больше 0');
	END IF;

	-- если не открыть курсор, то будет внутренняя ошибка с номером ORA-01001 INVALID_CURSOR
    OPEN subscriber_cursor;


    -- Перебираем результаты курсора
    LOOP
        FETCH subscriber_cursor INTO f_ORD_sender_name, f_ORD_sender_address, f_ORD_sender_phone, orders_count;
        EXIT WHEN subscriber_cursor%NOTFOUND;

        -- Выводим результаты в SQL*Plus
        DBMS_OUTPUT.PUT_LINE(
            'Имя отправителя: ' || f_ORD_sender_name ||
            ', Адрес отправителя: ' || f_ORD_sender_address ||
            ', Телефон отправителя: ' || f_ORD_sender_phone ||
            ', количество заказов: ' || orders_count);

        -- Увеличиваем счетчик общего количества подписчиков
        total_subscribers := total_subscribers + 1;

    END LOOP;

    -- Закрываем курсор
    CLOSE subscriber_cursor;

    -- Возвращаем общее количество подписчиков
    RETURN total_subscribers;
EXCEPTION
    WHEN correct_year THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN correct_threshold THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('В таблице orders нет данных за указанный год.');
	when INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('Вы не корректно работаете с курсором');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLCODE || ' - ' || SQLERRM);   
END local_subscribers_with_more_subscriptions;

FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN VARCHAR2) RETURN NUMBER IS
   CURSOR subscriber_cursor IS
      SELECT ORD_sender_name, ORD_sender_address, ORD_sender_phone, COUNT(order_num) AS orders_count
      FROM orders
      WHERE EXTRACT(YEAR FROM ORD_package_receipt_date) = year
      GROUP BY ORD_sender_name, ORD_sender_address, ORD_sender_phone
      HAVING COUNT(order_num) > threshold;
	  
	threshold_num Number;
	f_ORD_sender_name VARCHAR2(40);
	f_ORD_sender_address VARCHAR2(50);
	f_ORD_sender_phone CHAR(17);
	orders_count NUMBER;
	total_subscribers NUMBER := 0;
		
	correct_year exception;
	PRAGMA EXCEPTION_INIT (correct_year, -20001);

	correct_threshold exception;
	PRAGMA EXCEPTION_INIT (correct_threshold, -20002);
	
	FUNCTION correct_year_checking (year in Number)
	return Number
	IS
	result Number := 0;
	BEGIN
	IF year > EXTRACT(YEAR FROM sysdate) THEN
	result := 1;
	END IF;
	RETURN result;
	END correct_year_checking;

BEGIN	
	threshold_num := TO_NUMBER(threshold);

	if correct_year_checking(year) = 1 then	
	RAISE_APPLICATION_ERROR(-20001, 'Неверный год: ' || year);
	end if;
	
	IF threshold < 0 THEN
		RAISE_APPLICATION_ERROR(-20002, 'Пороговое значение заказов должно быть больше 0');
	END IF;

	-- если не открыть курсор, то будет внутренняя ошибка с номером ORA-01001 INVALID_CURSOR
    OPEN subscriber_cursor;


    -- Перебираем результаты курсора
    LOOP
        FETCH subscriber_cursor INTO f_ORD_sender_name, f_ORD_sender_address, f_ORD_sender_phone, orders_count;
        EXIT WHEN subscriber_cursor%NOTFOUND;

        -- Выводим результаты в SQL*Plus
        DBMS_OUTPUT.PUT_LINE(
            'Имя отправителя: ' || f_ORD_sender_name ||
            ', Адрес отправителя: ' || f_ORD_sender_address ||
            ', Телефон отправителя: ' || f_ORD_sender_phone ||
            ', количество заказов: ' || orders_count);

        -- Увеличиваем счетчик общего количества подписчиков
        total_subscribers := total_subscribers + 1;

    END LOOP;

    -- Закрываем курсор
    CLOSE subscriber_cursor;

    -- Возвращаем общее количество подписчиков
    RETURN total_subscribers;
EXCEPTION
    WHEN correct_year THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN correct_threshold THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('В таблице orders нет данных за указанный год.');
	when INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('Вы не корректно работаете с курсором');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLCODE || ' - ' || SQLERRM);
		return 0;
END local_subscribers_with_more_subscriptions;

END my_package;

/

____TESTING____:

____END____.
6.	
____TASK____: 
Написать анонимный PL/SQL-блок, в котором будут вызовы реализованных функций и 
процедур пакета с различными характерными значениями параметров для проверки 
правильности работы основных задач и обработки исключительных ситуаций.
____CODE____:
-- Использование пакета

DECLARE
year NUMBER := 2023;
--year NUMBER := 2023;
--year NUMBER := 2024;

--threshold_num NUMBER := 1;
--threshold_varchar CHAR(1) := '1';

threshold_num NUMBER := 0;
threshold_varchar CHAR(1) := '0';

--threshold_num NUMBER := 3;
threshold_varchar1 CHAR(3) := 'abc';

BEGIN
my_package.copy_orders_to_aux_table;
DBMS_OUTPUT.PUT_LINE(chr(10));
DBMS_OUTPUT.PUT_LINE('Количество подписчиков, оформивших более ' || threshold_num || ' подписки за год ' || year || ' : ' || my_package.local_subscribers_with_more_subscriptions(year, threshold_num));
DBMS_OUTPUT.PUT_LINE(chr(10));
DBMS_OUTPUT.PUT_LINE('Количество подписчиков, оформивших более ' || threshold_num || ' подписки за год ' || year || ' : ' || my_package.local_subscribers_with_more_subscriptions(year, threshold_varchar));
DBMS_OUTPUT.PUT_LINE('Количество подписчиков, оформивших более ' || threshold_num || ' подписки за год ' || year || ' : ' || my_package.local_subscribers_with_more_subscriptions(year, threshold_varchar1));
END;
/

____TESTING____:
____END____.
--------------------------

удалил что-то

delete from orders where order_num = 6;
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Petr Petrovich','Minsk, 12 Poaw a Street','+375(44)111-11-15',1,5,80,0.001,DATE '2023-10-03',50,250,'No','Yes',NULL,'Jack Harlow','Minsk, 22 st to Selmash','+375(44)166-31-24',3,10.20,1,'No');


delete from orders where order_num = 10;
insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Hanna Michalevich','Minsk, 13 Ualskay a Street','+375(44)107-12-15',2,5,50,0.001,DATE '2023-10-03',100,150,'No','Yes',NULL,'Kanye West','Minsk, 43 st to Belitsa','+375(44)906-31-24',3,10.02,1,'No');

--------------------------

PROCEDURE copy_orders_to_aux_table;

FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN NUMBER) RETURN NUMBER;

FUNCTION local_subscribers_with_more_subscriptions(year IN NUMBER, threshold IN VARCHAR2) RETURN NUMBER ;

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------5 LABA------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
1.	
____TASK____: Написать DML-триггер, регистрирующий изменение данных (вставку, обновление, удаление) в одной из таблиц БД. Во 
вспомогательную таблицу LOG1 записывать, кто, когда (дата и время) и какое именно изменение произвел, для одного из столбцов 
сохранять старые и новые значения.
____CODE____:

CREATE TABLE log1 (
    user_name VARCHAR2(255),
    change_type VARCHAR2(255),
    change_date TIMESTAMP,
    change_column VARCHAR2(255),
    old_value VARCHAR2(255),
    new_value VARCHAR2(255)
);

CREATE OR REPLACE TRIGGER log_orders_changes
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW
DECLARE 
	username VARCHAR2(255);
	current_timestamp TIMESTAMP;
	defined_column CHAR(15);
	changetype VARCHAR2(255);
BEGIN

    -- Получаем имя пользователя, который произвел изменение
	SELECT user INTO username
	FROM dual
	WHERE user = USER;

    -- Получаем дату и время изменения
	SELECT sysdate INTO current_timestamp
	from dual;

    -- Определяем тип изменения
	IF INSERTING THEN
		changetype := 'INSERT';
	ELSIF UPDATING THEN
		changetype := 'UPDATE';
	ELSE
		changetype := 'DELETE';
	END IF;

    -- Определяем столбец, для которого нужно сохранить старые и новые значения
	defined_column := 'ORD_sender_name';
	
    -- Сохраняем данные в вспомогательную таблицу
    INSERT INTO log1 (
        user_name,
        change_type,
        change_date,
        change_column,
        old_value,
        new_value
    ) VALUES (
        username,
        changetype,
        current_timestamp,
        defined_column,
        :OLD.ORD_sender_name,
        :NEW.ORD_sender_name
    );
END;
/
____TESTING____:
delete from orders where Order_num = 14;

UPDATE orders
SET ORD_sender_name = 'Lolita'
WHERE Order_num = 13;

UPDATE orders
SET ORD_recipient_name = 'Bukovski Charlse'
WHERE Order_num = 11;

insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Kanye West', 'Minsk, Tsarikova. 47','+375(44)511-12-12',2,5,400,0.01,DATE '2023-10-11',20,50,'Yes','No',NULL,'Tarasov P.P.','Brest, Marochkina str. 23','+375(44)511-21-23',3,518.40,1,'Yes');
____END____.

2.
____TASK____: 
Написать DDL-триггер, протоколирующий действия пользователей по созданию, изменению и 
удалению таблиц в схеме во вспомогательную таблицу LOG2 в определенное время и запрещающий 
эти действия в другое время.
____CODE____:

GRANT CREATE TRIGGER, ALTER TRIGGER TO iosu_labs;

-- CREATE TABLE log2 (
  -- id_log2 number GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1 NOCACHE),
  -- username VARCHAR2(255),
  -- action VARCHAR2(255),
  -- change_date TIMESTAMP,
  -- table_name VARCHAR2(255),
  -- statements varchar2(1000),
  -- primary key(id_log2)
-- );

CREATE TABLE log2 (
  id_log2 number GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1 NOCACHE),
  username VARCHAR2(255),
  action VARCHAR2(255),
  change_date TIMESTAMP,
  table_name VARCHAR2(255),
  primary key(id_log2)
);


CREATE OR REPLACE TRIGGER log_ddl_actions
BEFORE CREATE OR ALTER OR DROP ON SCHEMA
DECLARE 
    user_name VARCHAR2(255);
    current_timestamp TIMESTAMP;
	allowed_hours NUMBER;
	tble_name VARCHAR2(255);
	act VARCHAR2(255);
	
	-- sql_text ora_name_list_t;
	-- v_stmt   VARCHAR2(2000);
	-- n        PLS_INTEGER;
	
	-- correct_time exception;
	-- PRAGMA EXCEPTION_INIT (correct_time, -20000);

BEGIN

-- n := ora_sql_txt(sql_text);
-- FOR i IN 1 .. n LOOP
-- v_stmt := v_stmt || sql_text(i);
-- END LOOP;


-- v_stmt :=regexp_replace(v_stmt,
											   -- 'rename[[:space:]]+.*[[:space:]]+to[[:space:]]+([a-z0-9_]+)',
											   -- '\1',
											   -- 1,
											   -- 1,
											   -- 'i');

  -- Получаем имя пользователя, который произвел изменение
	SELECT USER	
	INTO user_name
	FROM dual;

	SELECT CURRENT_TIMESTAMP INTO current_timestamp
	from dual;
	
	SELECT ORA_SYSEVENT INTO act FROM dual;
		
    -- Получаем имя изменяемой таблицы
 
    SELECT ORA_DICT_OBJ_NAME INTO tble_name FROM dual;


    -- Проверяем, находится ли текущее время в разрешенном интервале
	SELECT TO_NUMBER(TO_CHAR(SYSDATE, 'HH24')) INTO allowed_hours FROM dual;

	IF allowed_hours NOT BETWEEN 8 AND 22 THEN
		RAISE_APPLICATION_ERROR(-20000, 'DDL is not permitted during this time');
	END IF;
  	
  -- Регистрируем действие в вспомогательной таблице
  INSERT INTO log2 (
    username,
    action,
    change_date,
    table_name
) VALUES (
    user_name,
    act,
    current_timestamp,
    tble_name
  );
  
  
-- EXCEPTION
  -- -- Обработка ошибки -20001
  -- WHEN correct_time THEN
    -- DBMS_OUTPUT.PUT_LINE('Операция DDL запрещена в нерабочее время.');
    -- DBMS_OUTPUT.PUT_LINE('Пользователь: ' || user_name);
    -- DBMS_OUTPUT.PUT_LINE('Время: ' || current_timestamp);
    -- DBMS_OUTPUT.PUT_LINE('Таблица: ' || tble_name);
    -- DBMS_OUTPUT.PUT_LINE('Тип действия: ' || act);

END;
/

ALTER TRIGGER log_ddl_actions ENABLE;
____TESTING____:

CREATE TABLE log4 (
  username VARCHAR2(255),
  action VARCHAR2(255),
  change_date TIMESTAMP,
  table_name VARCHAR2(255)
);

ALTER TABLE LOG4
ADD new_column varchar2(255);

DROP TABLE LOG4; 

-- DROP TABLE your_table PURGE;
-- SHOW RECYCLEBIN

alter trigger log_ddl_actions disable;
alter trigger log_ddl_actions enable;

____END____.


3.
____TASK____: 
Написать системный триггер, добавляющий запись во вспомогательную таблицу LOG3, когда пользователь 
подключается или отключается. В таблицу логов записывается имя пользователя (USER), тип активности 
(LOGON или LOGOFF), дата (SYSDATE), количество записей в основной таблице БД
____CODE____:
CREATE TABLE log3 (
  id_log3 number GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1 NOCACHE),
  usr_name VARCHAR2(30),
  activity VARCHAR2(10),
  cur_date TIMESTAMP,
  records_count NUMBER
);

CREATE OR REPLACE TRIGGER LOG_USER_LOGON
AFTER LOGON ON DATABASE
DECLARE
  username VARCHAR2(30);
  activity VARCHAR2(10);
  currentdate TIMESTAMP;
  records_count NUMBER;
BEGIN

  -- Получаем имя пользователя
  username := USER;

  -- Определяем тип активности
  activity := 'LOGON';

  -- Получаем текущую дату
  SELECT CURRENT_TIMESTAMP INTO currentdate
  from dual;

  -- Получаем количество записей в основной таблице
  SELECT COUNT(*) INTO records_count
  FROM orders;

  -- Регистрируем событие в вспомогательной таблице
  INSERT INTO log3 (usr_name, activity, cur_date, records_count)
  VALUES (username, activity, currentdate, records_count);

END;
/

-- Триггер отключения клиента
CREATE OR REPLACE TRIGGER LOG_USER_LOGOFF
BEFORE LOGOFF ON DATABASE
DECLARE
 username VARCHAR2(30);
 activity VARCHAR2(10);
 currentdate TIMESTAMP;
 records_count NUMBER;
BEGIN
 -- Получаем имя пользователя
 username := USER;

 -- Определяем тип активности
 activity := 'LOGOFF';

  -- Получаем текущую дату
  SELECT CURRENT_TIMESTAMP INTO currentdate
  from dual;

 -- Получаем количество записей в основной таблице
 SELECT COUNT(*) INTO records_count
 FROM orders;

 -- Регистрируем событие в вспомогательной таблице
 INSERT INTO log3 (usr_name, activity, cur_date, records_count)
 VALUES (username, activity, currentdate, records_count);

END;
/

____TESTING____:
exit
log on
____END____.


4.
____TASK____: 
	Написать триггеры, реализующие бизнес-логику (ограничения) в заданной 
вариантом предметной области. Три задания приведены в прил. 6. Количество 
и тип триггеров (строковый или операторный, выполняется AFTER или BEFORE) 
определять самостоятельно исходя из сути заданий и имеющейся схемы БД; учесть, 
что в некоторых вариантах первые два задания могут быть выполнены в рамках 
одного триггера, а также возможно возникновение мутации, что приведет к совмещению 
данного пункта лабораторной работы со следующим. 
	Третий пункт задания предполагает использование планировщика задач, 
который обязательно должен быть настроен на многократный запуск с использованием 
частоты, интервала и спецификаторов.

1)Осуществлять контроль загруженности курьеров, например, по количеству 
одновременно обслуживаемых подписчиков. 
2)Осуществлять расчет стоимости подписки, при этом предусматривать, 
чтобы нельзя было подписаться менее чем на месяц и более чем на год, 
а дата оформления подписки должна быть не позднее 10 дней до ее начала.
3)Каждый месяц перемещать подписки с законченным сроком в архив.

____TASK____: 
1+2. Расчет стоимости заказа исходя из переданных параметров заказа
+ скидка, если большой вес посылки
{
	№1.осуществлять расчет стоимости заказа:
		а)каждый килограмм = 1 руб, изначально (ограничение по весу от 0.1 до 700 кг
	alter table orders 
	add constraint orders_package_weight
	check (ORD_PACKAGE_WEIGHT < 700 and ORD_PACKAGE_WEIGHT > 0.1);
		б)каждая тысячная метра кубического объема 0.001 = 0.5 руб
	alter table orders 
	add constraint orders_package_scope
	check (ORD_package_scope < 10 and ORD_package_scope > 0.001);
		в)объявленная стоимость:
	alter table orders 
	add constraint orders_package_declared_value
	check (ORD_declared_value_amount < 10000 and ORD_declared_value_amount > 5);
	> 100 рублей, то общая стоимость доставки увеличивается на 5% от объявленной стоимости
	> 1000 рублей, то общая стоимость доставки увеличивается на 10% от объявленной стоимости
		г)наложенный платеж: -
		д)хрупкое:
	если да, то + 10% от объявленной стоимости
	если нет, то -
		е)проверка получателем товара:
	если да, то + 1 процент от объявленной стоимости
	если нет, то -
		ж)тип доставки:
	если курьер, то + 5% от объявленной стоимости
	если грузовик, то + 1% от объявленной стоимости
		з)тип оплаты:
	если безнал, то - 1% от объявленной стоимости
	если нал, то -
	
	ALTER TABLE orders
	MODIFY ORD_declared_value_amount not NULL;

	ALTER TABLE orders
	MODIFY ORD_shipping_cost NULL;
	
	alter table Orders
	modify ORD_shipping_cost DECIMAL(30,2); 

	ALTER TRIGGER CALCULATE_SHIPPING_COST enable;

	№2.при отправке товаров весом более 100 кг, дополнительные 5 килограмм можно отправить 
	бесплатно. То есть, если вес груза больше 100 килограмм, то мы делим стоимость доставки на 
	вес груза и умножаем это число на (масса груза – 5 киллограм).
	если масса груза > 100 и < 200 кило, то бесплатно 5 кг
	если масса груза > 200 и < 300 кило, то бесплатно 15 кг
	если масса груза > 300 и < 400 кило, то бесплатно 25 кг
	если масса груза > 500 и < 600 кило, то бесплатно 35 кг
	если масса груза > 600 и < 700 кило, то бесплатно 45 кг
	если груз больше 700 кило, то мы не принимаем такой заказ - ввести ограничение в таблицу.

}

____CODE____:
---------------------------------------------------
---------------------------------------------------
-----ТРИГГЕР НА ФОРМИРОВАНИЕ СТОИМОСТИ ЗАКАЗА------
---------------------------------------------------
---------------------------------------------------
CREATE OR REPLACE TRIGGER CALCULATE_SHIPPING_COST
BEFORE INSERT OR UPDATE ON Orders
FOR EACH ROW
DECLARE
  shipping_cost DECIMAL(30,2) default 0.0;
  courier_code INTEGER;
  truck_code INTEGER;

  birth_day number;
  birth_month number;
  today_day number;
  today_month number;

BEGIN
--------------------------
-- РАСЧЕТ СТОИМОСТИ ЗАКАЗА
--------------------------
		-- а)каждый килограмм = 0.5 руб, изначально (ограничение по весу от 0.1 до 700 кг
		
			shipping_cost := shipping_cost + :new.ORD_package_weight*0.5;
		
		-- б)каждая тысячная метра кубического объема 0.001 = 0.1 руб
		
			shipping_cost := shipping_cost + :new.ORD_package_scope*100;
		
		-- в)объявленная стоимость:
		
			if :new.ORD_declared_value_amount >= 100 and :new.ORD_declared_value_amount < 1000 then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			elsif :new.ORD_declared_value_amount >= 1000 then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.2;
			end if;
		
		-- г)наложенный платеж: -
		-- д)хрупкое:
		
			-- если да, то + 10% от объявленной стоимости
			-- если нет, то -
			if :new.ORD_fragile = 'Yes' then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			end if;
		
		-- е)проверка получателем товара:
			-- если да, то + 1 процент от объявленной стоимости
			-- если нет, то -
			if :new.ORD_completeness_check = 'Yes' then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			end if;
		
		-- ж)тип доставки:
			-- если курьер, то + 5% от объявленной стоимости
			-- если грузовик, то + 1% от объявленной стоимости
			select DLV_code into courier_code
			from Delivery_type where DLV_delivery_method = 'Courier';

			select DLV_code into truck_code
			from Delivery_type where DLV_delivery_method = 'Truck';

			if :new.ORD_deliv_type_code = courier_code then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			elsif :new.ORD_deliv_type_code = truck_code then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.05;
			end if;
		
		-- з)тип оплаты:
			-- если безнал, то - 1% от объявленной стоимости
			-- если нал, то -
			if :new.ORD_cash_payment = 'No' then
				shipping_cost := shipping_cost - :new.ORD_declared_value_amount*0.01;
			end if;
--------------------------
-- СКИДКА ЗА ВЕС
--------------------------
	IF :new.ORD_PACKAGE_WEIGHT > 99 and :new.ORD_PACKAGE_WEIGHT < 200 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 5);
	elsif :new.ORD_PACKAGE_WEIGHT >= 200 and :new.ORD_PACKAGE_WEIGHT < 300 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 15);
	elsif :new.ORD_PACKAGE_WEIGHT >= 300 and :new.ORD_PACKAGE_WEIGHT < 400 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 25);
	elsif :new.ORD_PACKAGE_WEIGHT >= 400 and :new.ORD_PACKAGE_WEIGHT < 500 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 35);
	elsif :new.ORD_PACKAGE_WEIGHT >= 500 and :new.ORD_PACKAGE_WEIGHT < 600 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 45);
	elsif :new.ORD_PACKAGE_WEIGHT >= 600 and :new.ORD_PACKAGE_WEIGHT < 700 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 50);
	end if;
	
	select EXTRACT(DAY FROM :new.ord_sender_birth_day) into birth_day from dual;
	select EXTRACT(MONTH FROM :new.ord_sender_birth_day) into birth_month from dual;
	select EXTRACT(DAY FROM sysdate) into today_day from dual;
	select EXTRACT(MONTH FROM sysdate) into today_month from dual;
--------------------------
-- ПРОВЕРКА НА ДЕНЬ РОЖДЕНИЯ
--------------------------
	if birth_day = today_day and birth_month = today_month then
		  shipping_cost := shipping_cost * 0.8;
	END IF;
--------------------------
		
  -- Устанавливаем стоимость доставки
  :new.ORD_shipping_cost := shipping_cost;
	dbms_output.put_line('BIRTH: ' || :new.ord_sender_birth_day);
	dbms_output.put_line('cost: ' || :new.ORD_shipping_cost);

	dbms_output.put_line('CELEBRATE');
END;
/

------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
____TESTING____:
1:
UPDATE orders
SET ORD_declared_value_amount = 300
WHERE order_num = 4;

insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_deliv_type_code,ORD_cash_payment) values('Bogdanov Igor', 'Minsk, Pobediteley Ave. 48','+375(44)512-11-12',2,3,400,1,sysdate,200,50,'Yes','Yes',NULL,'Grishin P.P.','Grodno, Marchenko str. 23','+375(44)512-21-23',3,1,'No');

2:
UPDATE orders
SET ord_sender_birth_day = DATE '2002-10-16'
WHERE order_num = 4;

UPDATE orders
SET ORD_sender_name = 'Kanye West'
WHERE ORD_sender_name = 'JAY Z';

____END____.


____TASK____: 
3.МУТАЦИИ: 
СОЗДАЕМ КОЛОНКУ, КОТОРАЯ БУДЕТ 
ЕСЛИ ЗАКАН ЗАБРАН, НО ОБНОВИТЬ КОЛОНКУ
С ДАТОЙ, КОГДА ПОСЫЛКУ ЗАБРАЛИ

ЕСЛИ ПОСЫЛКУ ЗАБРАЛИ, ТО МЕНЯЕТСЯ ЗНАЧЕНИЕ КОЛОНКИ ord_picked_up 
ТОГДА ДОЛЖНА ОБНОВЛЯТЬСЯ КОЛОНКА С ДАТОЙ, КОГДА ЗАКАЗ ЗАБРАЛИ.
РАБОТНИК НАЖИМАЕТ - "ЗАКАЗ ЗАБРАН", А В БАЗЕ 
СОХРАНЯЕТСЯ ДЕНЬ И ВРЕМЯ, КОГДА ЗАКАЗ БЫЛ ЗАБРАН
----------------------------ИСХОДНЫЙ ВАРИАНТ-----------------------------
____CODE____:
create or replace trigger trg1
before INSERT OR UPDATE of ord_picked_up
on orders 
for each row
begin
	if(:new.ord_picked_up = 'Yes') then
     
	 update orders
         set ord_picked_up_date = current_timestamp
       where order_num = :new.order_num;
    end if;
  
  dbms_output.put_line('hellll_1');
end trg1; 
/

____TESTING____:
	 update orders
         set ord_picked_up = 'Yes'
       where order_num = 2;

RESULT: SQL>  update orders
  2           set ord_picked_up = 'Yes'
  3         where order_num = 1;
BIRTH: 12-SEP-03
cost: 31.1
CELEBRATE
 update orders
*
ERROR at line 1:
ORA-04091: table IOSU_LABS.ORDERS is mutating, trigger/function may not see it
ORA-06512: at "IOSU_LABS.TRG1", line 4
ORA-04088: error during execution of trigger 'IOSU_LABS.TRG1'

----------------------------ИСПРАВЛЕННЫЙ ВАРИАНТ-----------------------------
____CODE____:
CREATE OR REPLACE PACKAGE pkg_around_mutation AS
  pUpdPickUpState boolean default false;
  order_number orders.Order_num%type;
  procedure update_picked_up_state; 
END;
/

create or replace package body pkg_around_mutation
is
  procedure update_picked_up_state
  is 
  begin   
    if pUpdPickUpState then
      pUpdPickUpState := false;
		
	update orders
		set ord_picked_up_date = current_timestamp
	where order_num = pkg_around_mutation.order_number;
	
    end if;
	
  end update_picked_up_state;

end pkg_around_mutation;
/


create or replace trigger trg1
before INSERT OR UPDATE of ord_picked_up
on orders 
for each row
begin
	if(:new.ord_picked_up = 'Yes') then 
		pkg_around_mutation.order_number := :new.Order_num;
		pkg_around_mutation.pUpdPickUpState := true;  
	end if;
	
end trg1; 
/

create or replace trigger trg2
after insert or update of ord_picked_up
on orders
begin
  pkg_around_mutation.update_picked_up_state;  
end trg2;
/ 


____TESTING____:
	update orders
        set ord_picked_up = 'Yes'
    where order_num = 3;

____END____.


____TASK____: 
4. планировщик:
раз в месяц копировать строки с заказами, которые забрали(галочка столбца с мутацией)

планировщика задач, который будет раз в месяц копировать строки с заказами, которые забрали и
 должен быть настроен на многократный запуск с использованием частоты, интервала и спецификаторов.

ДОБАВЛЯЮ СТОЛБЕЦ ТИПА BOOL, КОТОРЫЙ БУДЕТ СОХРАНЯТЬ ЗНАЧЕНИЕ О ТОМ, ЗАБРАЛИ 
ПОСЫЛКУ ИЛИ НЕТ

ALTER TABLE orders 
add ord_picked_up varchar2(3) DEFAULT 'No';

alter table orders add CONSTRAINT ORD_order_picked_up
CHECK(ord_picked_up IN('Yes','No'));

И, ДОБАВЛЯЮ СТОЛБЕЦ, КОТОРЫЙ БУДЕТ ХРАНИТЬ ДАТУ, КОГДА ПОСЫЛКУ ЗАБРАЛИ

ALTER TABLE orders 
ADD ord_picked_up_date TIMESTAMP;

____CODE____:
CREATE TABLE order_archive(
					order_archive_id INTEGER generated by default as identity(nocache),
					Order_num INTEGER,
					ORD_sender_name VARCHAR2(40) NOT NULL,
					ORD_sender_address VARCHAR2(50) NOT NULL,
					ORD_sender_phone CHAR(17) NOT NULL,
					ORD_sending_office INTEGER NOT NULL,
					ORD_employee_placing_the_order_num INTEGER NOT NULL,
					ORD_package_weight DECIMAL(20,3) NOT NULL,
					ORD_package_scope DECIMAL(20,3) NOT NULL,
                    ORD_package_receipt_date DATE NOT NULL,
					ORD_declared_value_amount DECIMAL(30,3),
					ORD_cash_on_dlvry_amount DECIMAL(30,3),
					ORD_fragile VARCHAR2(3) NOT NULL,
					ORD_completeness_check VARCHAR2(3) NOT NULL,
                    ORD_arrival_date DATE,
					ORD_recipient_name VARCHAR2(40) NOT NULL,
					ORD_recipient_address VARCHAR2(50) NOT NULL,
					ORD_recipient_phone CHAR(17) NOT NULL,
					ORD_receiving_office INTEGER NOT NULL,
					ORD_shipping_cost DECIMAL(30,3) NOT NULL,
					ORD_deliv_type_code INTEGER NOT NULL,
					ORD_cash_payment VARCHAR2(3) NOT NULL,
					ord_sender_birth_day DATE,
					ord_picked_up_date TIMESTAMP,
					ord_picked_up VARCHAR2(3),
					ONLY_SENDER_NAME VARCHAR2(50),
					ONLY_SENDER_SURNAME VARCHAR2(50),
					ONLY_SENDER_PATRONYMIC VARCHAR2(50),
					PRIMARY KEY(order_archive_id));


CREATE OR REPLACE PROCEDURE copy_orders
AS
  today_month number;
  prev_month number;
BEGIN
	select EXTRACT(MONTH FROM sysdate) into today_month from dual;

	if today_month = 1 then
		prev_month := 12;
	else
		prev_month := today_month - 1;
	end if;
	
  -- Копируем строки с заказами, которые забрали
  INSERT INTO order_archive(Order_num,ORD_sender_name,
					ORD_sender_address, ORD_sender_phone, ORD_sending_office,
					ORD_employee_placing_the_order_num,	ORD_package_weight,
					ORD_package_scope, ORD_package_receipt_date,
					ORD_declared_value_amount, ORD_cash_on_dlvry_amount,
					ORD_fragile, ORD_completeness_check, ORD_arrival_date,
					ORD_recipient_name, ORD_recipient_address, ORD_recipient_phone,
					ORD_receiving_office, ORD_shipping_cost, ORD_deliv_type_code,
					ORD_cash_payment, ord_sender_birth_day, ord_picked_up_date, ord_picked_up, ONLY_SENDER_NAME, ONLY_SENDER_SURNAME, ONLY_SENDER_PATRONYMIC)
	SELECT Order_num,ORD_sender_name,
		   ORD_sender_address, ORD_sender_phone, ORD_sending_office,
		   ORD_employee_placing_the_order_num,    ORD_package_weight,
		   ORD_package_scope, ORD_package_receipt_date,
		   ORD_declared_value_amount, ORD_cash_on_dlvry_amount,
		   ORD_fragile, ORD_completeness_check, ORD_arrival_date,
		   ORD_recipient_name, ORD_recipient_address, ORD_recipient_phone,
		   ORD_receiving_office, ORD_shipping_cost, ORD_deliv_type_code,
		   ORD_cash_payment, ord_sender_birth_day, ord_picked_up_date, ord_picked_up, ONLY_SENDER_NAME, ONLY_SENDER_SURNAME, ONLY_SENDER_PATRONYMIC
    FROM orders
    WHERE orders.ord_picked_up = 'Yes' and EXTRACT(MONTH FROM orders.ord_picked_up_date) = prev_month;
END;
/

BEGIN
DBMS_SCHEDULER.CREATE_JOB
( job_name => 'job_copy_orders',
 job_type => 'STORED_PROCEDURE',
 job_action => 'copy_orders',
 repeat_interval => 'FREQ=MINUTELY;INTERVAL=1',
 start_date => SYSTIMESTAMP,
 end_date => NULL,
 enabled => TRUE);

DBMS_SCHEDULER.ENABLE ('job_copy_orders');
END;
/

BEGIN
dbms_scheduler.drop_job('job_copy_orders');
END;
/

BEGIN
DBMS_SCHEDULER.CREATE_JOB
( job_name => 'job_copy_orders',
 job_type => 'STORED_PROCEDURE',
 job_action => 'copy_orders',
 repeat_interval => 'FREQ=MONTHLY;BYMONTHDAY=1',
 start_date => SYSTIMESTAMP,
 end_date => NULL,
 enabled => TRUE);

DBMS_SCHEDULER.ENABLE ('job_copy_orders');
END;
/
____TESTING____:
____END____.


____TASK____: 
6.	Написать триггер INSTEAD OF для работы с не обновляемым представлением, 
созданным после выполнения п. 2.4 задания к лабораторной работе №3, проверить 
DML-командами возможность обновления представления после включения триггера 
(логика работы триггера определяется спецификой предметной области варианта).

-- 2.3)Создать вертикальное или смешанное необновляемое представление, предназначенное для работы с основной таблицей 
-- БД (в представлении должны содержаться сведения из основной дочерней таблицы и/или корзины (если есть), но вместо 
-- внешних ключей использовать связанные данные родительских таблиц, понятные конечному пользователю представления);
-- 2.4) доказать необновляемость представления из предыдущего пункта, проверив возможность 
-- выполнения инструкций UPDATE, DELETE, INSERT над представлением. Сохранить полученный результат 
-- (сообщение об ошибке или об успешном выполнении), объяснить причины;
ALTER TRIGGER view2_third DISABLE;

create or replace view view2_third AS
select distinct 
orders.order_num as order_number,
orders.ORD_sender_name as order_sender_name,
orders.ORD_sender_address as order_sender_address,
orders.ORD_sender_phone as order_sender_phone,
orders.ORD_sending_office as order_sending_office,
orders.ORD_employee_placing_the_order_num as order_employe_placing_order,
orders.ORD_package_weight as order_package_weight,
orders.ORD_package_scope as order_package_scope,
orders.ORD_package_receipt_date as order_package_receipt_date,
orders.ORD_declared_value_amount as order_declared_value_amount,
orders.ORD_fragile as order_fragile,
orders.ORD_COMPLETENESS_CHECK as order_completeness,
orders.ORD_recipient_name as order_recipient_name,
orders.ORD_recipient_address as order_recipient_address,
orders.ORD_recipient_phone as order_recipient_phone,
orders.ORD_receiving_office as order_receiving_office,
orders.ORD_shipping_cost as order_shipping_cost,
orders.ORD_deliv_type_code as order_deliv_type_code,
orders.ORD_cash_payment as order_cash_payment,
orders.ORD_SENDER_BIRTH_DAY as order_sender_birth_date,
orders.ord_picked_up_date as order_picked_up_date,
orders.ord_picked_up as order_picked_up,
delivery_type.dlv_delivery_method as delivery_method,
branch.branch_num as branch_number,
branch.BR_address as branch_sending_office_address,
branch.BR_max_storage_capacity as branch_max_storage_capacity,
branch.BR_principal_employee_name as branch_princip_employee_name,
branch.BR_principal_employee_phone as branch_princip_employee_phone,
branch.BR_employee_num as branch_employee_num,
branch.BR_ceo_director as branch_ceo,
staff.stf_name as staff_name,
staff.STF_birth_date as staff_birth_date,
staff.STF_address as staff_address,
staff.STF_position_code as staff_pos_code,
staff.STF_email as staff_email,
staff.STF_passport_details as staff_passport_data,
staff.STF_branch_num as staff_branch_num,
staff.STF_phone_num as staff_phone_num
from orders
left join branch on orders.ORD_sending_office = branch.branch_num
left join delivery_type on orders.ORD_deliv_type_code = delivery_type.DLV_code
left join staff on orders.ORD_employee_placing_the_order_num = staff.Staff_num
where to_char(orders.ORD_package_receipt_date, 'MM') = '03';

select * from view2_third;

insert into view2_third(
order_sender_name, 
order_sender_address, 
order_sender_phone, 
--order_sending_office,
--order_employe_placing_order, 
order_package_weight, 
order_package_scope, 
order_package_receipt_date,
order_declared_value_amount, 
order_fragile, 
order_completeness,
order_recipient_name, 
order_recipient_address,
order_recipient_phone, 
order_receiving_office, 
--order_deliv_type_code,
order_cash_payment, 
order_sender_birth_date,
delivery_method, 
branch_sending_office_address, 
branch_max_storage_capacity, 
branch_employee_num, 
branch_ceo, 
staff_name, 
staff_birth_date,
staff_address,
staff_pos_code, 
staff_email, 
staff_passport_data, 
staff_phone_num)
values ('Luka Doncic', 
'Frunze Ave 27, Viciebsk', 
'+375(44)141-55-12',
100,
0.1,
DATE '2023-03-30', -- if sysdate then view won't be inserted. right way DATE '2023-03-30'
100,
'Yes',
'Yes',
'Michael Jordan',
'Praspiekt Kasmanaŭtaŭ 100, Grodno',
'+375(29)140-55-12',
3,
'Yes',
DATE '2003-03-30',
'Plain',
'Gup Vileyskoye Zhkkh, Ulitsa Partizanskaya 36',
30,
1,
16,
'Pusha T',
DATE '2003-09-30',
'Moskovskiy Prospekt 33, Viciebsk',
2,
'pusha_t@gmail.com',
'HB2661252',
'+375(29)100-66-12');


update view2_third
	set order_sender_name = 'medvedev'
where order_number = 3;


delete from view2_third
where order_number = 7;

ALTER TRIGGER order_info_insert enable;

delete from view2_third
where order_number = 7;

____CODE____:

CREATE OR REPLACE TRIGGER order_info_insert
   INSTEAD OF UPDATE OR INSERT OR DELETE ON view2_third
   for each row
   DECLARE
     duplicate_info EXCEPTION;
     PRAGMA EXCEPTION_INIT (duplicate_info, -00001);
	 	 
	 uncorrect_date EXCEPTION;
     PRAGMA EXCEPTION_INIT (uncorrect_date, -00002);

	 invalid_order_num EXCEPTION;
     PRAGMA EXCEPTION_INIT (invalid_order_num, -00003);

	 t_branch_number integer;
	 t_delivery_method integer;
	 t_employee_number integer;
	 t_order_number integer;
	 t_temp_recieve_month char(2);
	 t_temp_recieve_date date;
	 
   BEGIN
	CASE
        WHEN INSERTING then
			if to_char(:new.order_package_receipt_date, 'MM') != '03' then
			RAISE uncorrect_date;
			end if;
			
			 insert into Delivery_type(DLV_delivery_method) 
			 values (:new.delivery_method);
				 
			 select DLV_code into t_delivery_method from delivery_type where DLV_delivery_method = :new.delivery_method;

			 insert into branch(BR_max_storage_capacity,BR_principal_employee_name,
			 BR_principal_employee_phone,BR_address,BR_employee_num, BR_ceo_director)
			 values (:new.branch_max_storage_capacity, :new.staff_name, :new.staff_phone_num,
			 :new.branch_sending_office_address, :new.branch_employee_num, :new.branch_ceo);
			 
			 select Branch_num into t_branch_number from Branch where BR_principal_employee_name = :new.staff_name;
			 --нужен номер отделения, чтобы сотруднику его определить
			 -- создаю работника, который будет главным в отделении и примет заказ
			 insert into staff(stf_name, STF_birth_date, STF_address,
			 stf_position_code,STF_email,STF_passport_details,
			 STF_branch_num,STF_phone_num) values (:new.staff_name,
			 :new.staff_birth_date, :new.staff_address, :new.staff_pos_code,
			 :new.staff_email, :new.staff_passport_data, t_branch_number, 
			 :new.staff_phone_num);
			 
			 select staff_num into t_employee_number from staff where stf_name = :new.staff_name;
			 
			insert into Orders(ORD_sender_name,ORD_sender_address,
			ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,
			ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,
			ORD_declared_value_amount,ORD_fragile,ORD_completeness_check,ORD_recipient_name,
			ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,
			ORD_deliv_type_code,ORD_cash_payment,ORD_SENDER_BIRTH_DAY) 
			values(:new.order_sender_name, :new.order_sender_address,
			:new.order_sender_phone, t_branch_number, t_employee_number,
			:new.order_package_weight, :new.order_package_scope,
			:new.order_package_receipt_date, :new.order_declared_value_amount,
			:new.order_fragile, :new.order_completeness, :new.order_recipient_name, 
			:new.order_recipient_address, :new.order_recipient_phone, 
			:new.order_receiving_office, t_delivery_method, :new.order_cash_payment, 
			:new.order_sender_birth_date);
			
		when DELETING then			
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :old.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
		
			DELETE FROM ORDERS WHERE Order_num = :old.order_number;
		
		when updating('order_sender_name') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sender_name = :new.order_sender_name
			where order_num = :new.order_number;
	
			
		when updating('order_sender_address') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sender_address = :new.order_sender_address
			where order_num = :new.order_number;
			
		when updating('order_sender_phone') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sender_phone = :new.order_sender_phone
			where order_num = :new.order_number;
			
		when updating('order_sending_office') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sending_office = :new.order_sending_office
			where order_num = :new.order_number;
			
		when updating('order_employe_placing_order') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_employee_placing_the_order_num = :new.order_employe_placing_order
			where order_num = :new.order_number;
			
		when updating('order_package_weight') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_package_weight = :new.order_package_weight
			where order_num = :new.order_number;
			
		when updating('order_package_scope') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_package_scope = :new.order_package_scope
			where order_num = :new.order_number;
			
		when updating('order_package_receipt_date') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_package_receipt_date = :new.order_package_receipt_date
			where order_num = :new.order_number;
			
		when updating('order_declared_value_amount') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_declared_value_amount = :new.order_declared_value_amount
			where order_num = :new.order_number;
			
		when updating('order_fragile') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_fragile = :new.order_fragile
			where order_num = :new.order_number;
			
		when updating('order_completeness') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_COMPLETENESS_CHECK = :new.order_completeness
			where order_num = :new.order_number;

		when updating('order_recipient_name') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_recipient_name = :new.order_recipient_name
			where order_num = :new.order_number;
			
		when updating('order_recipient_address') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_recipient_address = :new.order_recipient_address
			where order_num = :new.order_number;
			
		when updating('order_recipient_phone') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_recipient_phone = :new.order_recipient_phone
			where order_num = :new.order_number;
			
		when updating('order_receiving_office') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_receiving_office = :new.order_receiving_office
			where order_num = :new.order_number;
			
		when updating('order_shipping_cost') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_shipping_cost = :new.order_shipping_cost
			where order_num = :new.order_number;
			
		when updating('order_deliv_type_code') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_deliv_type_code = :new.order_deliv_type_code
			where order_num = :new.order_number;
			
		when updating('order_cash_payment') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_cash_payment = :new.order_cash_payment
			where order_num = :new.order_number;
			
		when updating('order_sender_birth_date') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_SENDER_BIRTH_DAY = :new.order_sender_birth_date
			where order_num = :new.order_number;
			
		when updating('order_picked_up_date') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ord_picked_up_date = :new.order_picked_up_date
			where order_num = :new.order_number;
			
		when updating('order_picked_up') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ord_picked_up = :new.order_picked_up
			where order_num = :new.order_number;
			
		-- when updating(delivery_method) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;		
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_number) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_sending_office_address) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_max_storage_capacity) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_princip_employee_name) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_princip_employee_phone) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_employee_num) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_ceo) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_name) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_birth_date) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_address) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_pos_code) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_email) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_passport_data) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_branch_num) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_phone_num) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;		


end case;
		   
   EXCEPTION
     WHEN duplicate_info THEN
       RAISE_APPLICATION_ERROR (
         num=> -20107,
         msg=> 'Duplicate customer or order ID');
	 WHEN uncorrect_date THEN
       RAISE_APPLICATION_ERROR (
         num=> -20107,
         msg=> 'Uncorrect date');
	 WHEN invalid_order_num THEN
       RAISE_APPLICATION_ERROR (
         num=> -20107,
         msg=> 'There is no order with that number');

		 

END order_info_insert;
/


____TESTING____:


____END____.


-----------------------------18.10
когда главный отделения становится главным отделением 2 категории,
то сотрудники становятся сотрудниками 2 категории


insert INTO Positions(PST_name,PST_min_level_of_education_code,PST_min_salary,PST_employee_availability,PST_driver_license,PST_english_A2_required) VALUES 
('Employee_second_category', 1, 1000, 'No', 'No', 'No');

insert INTO Positions(pst_name,PST_min_level_of_education_code,PST_min_salary,PST_employee_availability,PST_driver_license,PST_english_A2_required) VALUES 
('Branch_chief_second_category', 3, 1700, 'Yes', 'No', 'Yes');
  
  
  
create or replace trigger trigger_mut
  for update of STF_position_code
  on staff
  compound trigger
    bUpdPainters  boolean;
 
  before each row is
  begin
    if :new.STF_name = 'Shobic I.P.' and :old.STF_position_code = 2 and :new.STF_position_code = 7 then
      bUpdPainters := true;
    end if;
  end before each row;
  
  after statement is
  begin
    if bUpdPainters then
      update staff
         set STF_position_code = 6
       where STF_position_code = 1;
    end if;
  end after statement;
end trigger_mut; 
/



update staff
   set STF_position_code = 7
 where STF_name = 'Shobic I.P.' and stf_branch_num = 1;


____TASK____: 
№3.курьер должен в день развозить не менее 5 посылок; меньше – штраф 1% от оклада; 
больше 10 – премия в размере 2% от зп - как будто, это разумно делать раз в сутки,
то есть планировщик нужен
____CODE____:
alter table Staff
add salary decimal(20,2);


____TESTING____:
____END____.


____TASK____: 
4. если сотрудник работает > года, то его минимальная зарплата увеличивается всегда на 20% от минимальной зарплаты
если сотрудник работает > 3 лет, то его минимальная зарплата увеличивается всегда на 30% от минимальной зарплаты
если сотрудник работает > 5 лет, то его минимальная зарплата увеличивается всегда на 50% от минимальной зарплаты
типо, раз в месяц
____CODE____:


____TESTING____:
____END____.

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------6 LABA------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
____TASK____: 
1.	Написать с помощью пакета DBMS_SQL динамическую процедуру или функцию, в которой заранее неизвестен текст 
команды SELECT. Предусмотреть возможность вывода разных результатов, в зависимости от количества передаваемых 
параметров.
order by. having. from two tables. exception(если ...)
:
передавать в качестве первого параметра имя таблицы, а в качестве второго параметра коллекцию из переменных, 
которые мы хотим вывести

написать динамическую процедуру, которая будет принимать параметры для выбора данных из таблиц, 
то есть сначала мы коннектим две таблицы, и выбираем из них какие-то данные, например зп для сотрудников,
чей возраст больше 25 лет. если что-то не соответствует, то raise exception.
1.	Открытие курсора (OPEN_CURSOR).
2.	Выполнение грамматического разбора (PARSE).
3.	Выполнение привязки всех входных переменных (BIND_VARIABLE).
4.	Описание элементов списка выбора (DEFINE_COLUMN).
5.	Исполнение запроса (EXECUTE).
6.	Считывание строк (FETCH).
7.	Запись результатов в переменные (COLUMN_VALUE).
8.	Закрытие курсора (CLOSE_CURSOR).


order - ok - by 
having - это count > чем что-то, если правильно понимаю
если есть having, то должен быть count
exception

тогда, select, который будет выбирать инфу об отправителях, которые оформили 
количество заказов за указанный год больше, чем указано во входном параметре, 
а также, которые оформляли заказ в отделении, указанном во входном параметре.

				1)тогда, я буду передавать данные о столбцах, для которых я хочу получить данные.
				2)имена двух таблиц, которые я буду связывать.
				3)столбец, по которому я буду осуществлять count. 
				4)значение, больше которого должен быть having count.
				5)столбец, по которому должен осуществляться order by.
				
поэтому я должен сделать типы, в котором буду отдельно перечислять стоблцы и т.п.
____CODE____:
///////MY procedure

create or replace procedure select_dynamic_sql( 
	p_column_to_select IN six_one_columns_to_select_type,
	p_from_table IN varchar2,
	p_type_of_join IN six_one_join_type,
	p_tables_to_join_type IN six_one_tables_to_join_type,
	p_on_conditions IN six_one_on_conditions_type,
	p_number_of_count_column_in_select in NUMBER,
	p_order_by_column IN NUMBER,
	p_having_condition IN six_one_having_condition_type
)
IS 
sqltext varchar2(2000) := 'SELECT';
space_comma varchar2(2) := ' ';
from_word varchar2(10) := 'FROM';
join_word varchar2(10) := 'JOIN';
on_word varchar2(10) := 'ON';
groupby_word varchar2(10) := 'GROUP BY';
having_word varchar2(15) := 'HAVING COUNT(';
count_word varchar2(10) := 'COUNT(';
right_bracket varchar2(10) := ')';
orderby_word char(9) := 'ORDER BY';

p_column_to_select_index number;
p_type_of_join_index number;
p_column_to_group_by_index number;
p_having_column_index number;
p_order_by_column_index number;
p_on_conditions_index number;

p_columns_counter number;
p_having_counter number;
p_asterisk_flag number;

s VARCHAR2 (250);
table_cursor number;
cnt INTEGER;

TYPE col_inf_type IS RECORD (name VARCHAR2 (50),
value VARCHAR2 (1000));

TYPE list_col_type IS TABLE OF col_inf_type;
list_col list_col_type := list_col_type ();

asterisk_and_smthng_else_in_select EXCEPTION;
PRAGMA EXCEPTION_INIT (asterisk_and_smthng_else_in_select, -00001);

begin
	dbms_output.enable(100000);
	
	p_column_to_select_index := p_column_to_select.FIRST;
	p_type_of_join_index := p_type_of_join.FIRST;
	p_column_to_group_by_index := p_column_to_select.FIRST;
	p_having_column_index := p_column_to_select.FIRST;
	p_order_by_column_index := p_column_to_select.FIRST;
	p_on_conditions_index := p_on_conditions.FIRST;

	p_asterisk_flag := 0;
	p_having_counter := 0;
	p_columns_counter := 1;
	
	dbms_output.PUT_LINE(p_column_to_group_by_index);


-- ПРОВЕРКА, НЕ ПЕРЕДАНА ЛИ ТОЛЬКО ЗВЕЗДОЧКА
WHILE p_column_to_select_index IS NOT NULL LOOP
	IF p_column_to_select(p_column_to_select_index) = '*' AND p_asterisk_flag = 0 THEN
		p_asterisk_flag := 1;
	ELSIF p_asterisk_flag = 1 THEN
		RAISE asterisk_and_smthng_else_in_select;
	END IF;

    p_column_to_select_index := p_column_to_select.NEXT(p_column_to_select_index);
END LOOP;

IF p_asterisk_flag = 1 THEN
-- ЗВЕЗДОЧКА В SELECT
   FOR c IN (SELECT column_name FROM all_tab_columns
			  WHERE owner = UPPER (USER)
			  AND table_name = UPPER (p_from_table))
   LOOP
	IF p_columns_counter = p_number_of_count_column_in_select THEN
		sqltext:= sqltext || space_comma || count_word || c.column_name || right_bracket;
		space_comma := ', ';

	ELSE 
		sqltext:=
		sqltext || space_comma || c.column_name;
		space_comma:= ',';
	END IF;
	
	p_columns_counter := p_columns_counter + 1;
	
	list_col.EXTEND;
	list_col (list_col.LAST).name := c.column_name;
	   END LOOP;
ELSE 
-- НЕ ЗВЕЗДОЧКА В SELECT 
	p_column_to_select_index := p_column_to_select.FIRST;

	-----SELECT
	WHILE p_column_to_select_index IS NOT NULL LOOP
		-- access the array element
			
		-- ПРИ ПОМОЩИ dbms_output ПРОВЕРИТЬ С КАКОГО ЧИСЛА НАЧИНАЕТСЯ ОТСЧЕТ: начало с единицы
		IF p_column_to_select_index = p_number_of_count_column_in_select then
			sqltext:= sqltext || space_comma || count_word || p_column_to_select(p_column_to_select_index) || right_bracket;
			space_comma := ', ';
		ELSE 	
			sqltext := sqltext || space_comma || p_column_to_select(p_column_to_select_index);
			space_comma := ', ';	
		END IF;
		
		list_col.EXTEND;
		list_col(list_col.LAST).name := p_column_to_select(p_column_to_select_index);

		p_column_to_select_index := p_column_to_select.NEXT(p_column_to_select_index);
	END LOOP;
END IF;

	space_comma:= ' ';
	
-----FROM
	-- access the array element
	sqltext:= sqltext || space_comma || from_word || space_comma || p_from_table;
	
	space_comma := ' ';

-----... JOIN ON
WHILE p_type_of_join_index IS NOT NULL LOOP
	dbms_output.put_line('TATATAT');

	-- access the array element
	IF p_on_conditions_index IS NOT NULL THEN
	dbms_output.put_line('BABABABAB');
	sqltext:= sqltext || space_comma || p_type_of_join(p_type_of_join_index) || space_comma || 
		join_word || space_comma || p_tables_to_join_type(p_type_of_join_index) || space_comma || on_word || 
		space_comma || p_on_conditions(p_type_of_join_index) || space_comma;
	-- now we will open array that contain ON conditions
	ELSE 
	dbms_output.put_line('HAHAHHAHAAH');
	sqltext:= sqltext || space_comma || p_type_of_join(p_type_of_join_index) || space_comma || 
		join_word || space_comma || p_tables_to_join_type(p_type_of_join_index) || space_comma;
	END IF;

	p_type_of_join_index := p_type_of_join.NEXT(p_type_of_join_index);
END LOOP;

	space_comma := ' ';
	
------GROUP BY
p_columns_counter := 1;
IF p_asterisk_flag = 1 THEN
	-- ЗВЕЗДОЧКА В SELECT
	FOR c IN (SELECT column_name FROM all_tab_columns
			  WHERE owner = UPPER (USER)
			  AND table_name = UPPER (p_from_table))
	LOOP
	IF p_columns_counter != p_number_of_count_column_in_select THEN
		if groupby_word != ' ' then
			sqltext := sqltext || space_comma || groupby_word;
			groupby_word := ' ';
		end if;

		sqltext:= sqltext || space_comma || c.column_name;
		space_comma := ', ';
	END IF;

	p_columns_counter := p_columns_counter + 1;
	END LOOP;
ELSE
	WHILE p_column_to_group_by_index IS NOT NULL LOOP
		-- access the array element
		IF p_column_to_group_by_index != p_number_of_count_column_in_select then
			IF groupby_word != ' ' THEN
				sqltext := sqltext || groupby_word;
				groupby_word := ' ';
			END IF;

			sqltext := sqltext || space_comma || p_column_to_select(p_column_to_group_by_index);
			space_comma := ', ';
		END IF;

		p_column_to_group_by_index := p_column_to_select.NEXT(p_column_to_group_by_index);
	END LOOP;
END IF;

	space_comma := ' ';

-----HAVING COUNT
p_columns_counter := 1;
IF p_asterisk_flag = 1 THEN
	-- ЗВЕЗДОЧКА В SELECT
	FOR c IN (SELECT column_name FROM all_tab_columns
			  WHERE owner = UPPER (USER)
			  AND table_name = UPPER (p_from_table))
	LOOP
	IF p_columns_counter = p_number_of_count_column_in_select THEN
		p_having_counter := p_having_counter + 1;
		sqltext := sqltext || space_comma || having_word || c.column_name || right_bracket || 
		space_comma || p_having_condition(p_having_counter);
	END IF;

	p_columns_counter := p_columns_counter + 1;
	END LOOP;
ELSE
	WHILE p_having_column_index IS NOT NULL LOOP
		-- access the array element
		if p_having_column_index = p_number_of_count_column_in_select then
			p_having_counter := p_having_counter + 1;
			sqltext := sqltext || space_comma || having_word || p_column_to_select(p_having_column_index) || right_bracket || 
			space_comma || p_having_condition(p_having_counter);
		end if;
		
		p_having_column_index := p_column_to_select.NEXT(p_having_column_index);
	END LOOP;
END IF;
	
	space_comma := ' ';

-----ORDER BY
p_columns_counter := 1;
IF p_asterisk_flag = 1 THEN
	-- ЗВЕЗДОЧКА В SELECT
	FOR c IN (SELECT column_name FROM all_tab_columns
			  WHERE owner = UPPER (USER)
			  AND table_name = UPPER (p_from_table))
	LOOP
	IF p_columns_counter = p_order_by_column THEN
		p_having_counter := p_having_counter + 1;
		sqltext := sqltext || space_comma || orderby_word || c.column_name;
	END IF;

	p_columns_counter := p_columns_counter + 1;
	END LOOP;
ELSE
	WHILE p_order_by_column_index IS NOT NULL LOOP
		-- access the array element
		IF p_order_by_column_index = p_order_by_column THEN
			sqltext := sqltext || space_comma || orderby_word || p_column_to_select(p_order_by_column_index);
		END IF;
		
		p_order_by_column_index := p_column_to_select.NEXT(p_order_by_column_index);
	END LOOP;
END IF;
	
	dbms_output.put_line(sqltext);
	
	-- here we will parsing sqltext=select
	
	table_cursor := DBMS_SQL.open_cursor;
	
	DBMS_SQL.parse (table_cursor, sqltext, DBMS_SQL.native);
	
	
	FOR i IN list_col.FIRST ..list_col.LAST
	LOOP
		DBMS_SQL.DEFINE_COLUMN (table_cursor, i, list_col(i).VALUE, 1000);
	END LOOP;

	cnt := DBMS_SQL.EXECUTE (table_cursor);
	
	-- DBMS_OUTPUT.put_line ('Введенный запрос '
						 -- || ' содержит '
						 -- || cnt
						 -- || ' строк.');
	cnt := 0;


	LOOP
		IF DBMS_SQL.fetch_rows(table_cursor) = 0 THEN
			EXIT;
		END IF;
		cnt := cnt + 1;
		s := cnt || '.';
		
		FOR i IN list_col.FIRST ..list_col.LAST
		LOOP
			DBMS_SQL.column_value(table_cursor, i, list_col(i).VALUE);
			s := s || ' ' || list_col(i).VALUE;
		END LOOP;
		
		DBMS_OUTPUT.put_line (SUBSTR (s, 1, 255));
	END LOOP;
	DBMS_SQL.close_cursor (table_cursor);

	EXCEPTION
	WHEN asterisk_and_smthng_else_in_select THEN
		DBMS_OUTPUT.PUT_LINE('В Select передана не только звездочка "*"');
	when others then 
	IF SQLCODE = -936 THEN
		  DBMS_OUTPUT.PUT_LINE('Ошибка: ORA-00936: Некорректные данные при перечислении стобцов в SELECT');
	ELSIF SQLCODE = -903 THEN
		  DBMS_OUTPUT.PUT_LINE('Ошибка: ORA-00903: Некорректные имена таблиц');
	ELSIF SQLCODE = -933 THEN
		  DBMS_OUTPUT.PUT_LINE('Ошибка: ORA-00933: Некорректно определен тип соединения таблиц');
	ELSIF SQLCODE = -920 THEN
		  DBMS_OUTPUT.PUT_LINE('Ошибка: ORA-00936: Некорректно введены условия');
	ELSE
	  DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);
		END IF;

end;
/

//////////////CREATING NEW TYPES OF DATA
    -- declare an associative array type
    CREATE OR REPLACE TYPE six_one_columns_to_select_type IS TABLE OF varchar2(100);
	/
	CREATE OR REPLACE TYPE six_one_join_type IS TABLE OF varchar2(100);
	/
	CREATE OR REPLACE TYPE six_one_on_conditions_type IS TABLE OF varchar2(100);
	/
	CREATE OR REPLACE TYPE six_one_tables_to_join_type IS TABLE OF varchar2(100);
	/
	CREATE OR REPLACE TYPE six_one_having_condition_type IS TABLE OF varchar2(100);
	/

begin
dbms_output.put_line('hahahah');
end;
/


///////MY ANONYMOUS BLOCK
DECLARE
    six_one_columns_to_select six_one_columns_to_select_type := six_one_columns_to_select_type();
	six_one_from_table varchar2(100);
	six_one_type_of_join six_one_join_type := six_one_join_type();
	six_one_on_conditions six_one_on_conditions_type := six_one_on_conditions_type();
	six_one_number_of_count_column_in_select number;
	six_one_order_by_column number;
	six_one_tables_to_join six_one_tables_to_join_type := six_one_tables_to_join_type();
	six_one_having_condition six_one_having_condition_type := six_one_having_condition_type();
BEGIN
    -- six_one_columns_to_select := six_one_columns_to_select_type('ORDER_NUM', 
	-- 'ORD_SENDER_NAME', 'ORD_SENDER_ADDRESS', 'ORD_SENDER_PHONE');
	
    six_one_columns_to_select := six_one_columns_to_select_type('*');
	
	six_one_from_table := 'ORDERS';

    -- six_one_type_of_join := six_one_join_type('CROSS');
	-- six_one_type_of_join := six_one_join_type('INNER');

	six_one_tables_to_join := six_one_tables_to_join_type('BRANCH');
	-- six_one_tables_to_join := six_one_tables_to_join_type('POSITIONS');

	-- six_one_on_conditions := six_one_on_conditions_type('ORD_SENDING_OFFICE = BRANCH_NUM AND BRANCH_NUM = 1');
	-- six_one_on_conditions := six_one_on_conditions_type('ORD_SENDING_OFFICE = POSITION_CODE AND POSITION_CODE = 1');

	-- six_one_number_of_count_column_in_select := 1;
	
	six_one_order_by_column := 1;
	
	-- six_one_having_condition := six_one_having_condition_type('> 0');
	
	-- now we will call procedure
	
	select_dynamic_sql(six_one_columns_to_select, six_one_from_table,
	six_one_type_of_join, six_one_tables_to_join, six_one_on_conditions, six_one_number_of_count_column_in_select,
	six_one_order_by_column, six_one_having_condition);
	
END;
/
/////////////////////////////////////////////////////////////////////////////
____TESTING____:
____END____.


____TASK____: 
6.2. Написать, используя встроенный динамический SQL, процедуру создания в БД нового 
объекта (представления или таблицы) на основе существующей таблицы. Имя нового объекта 
должно формироваться динамически и проверяться на существование в словаре данных. В качестве 
входных параметров указать тип нового объекта, исходную таблицу, столбцы и количество строк, 
которые будут использоваться в запросе.
____CODE____:
CREATE OR REPLACE PROCEDURE six_two_CreateNewObject(
    p_object_type IN VARCHAR2,
    p_source_table IN VARCHAR2,
    p_columns IN VARCHAR2,
    p_row_count IN NUMBER
) AS
    v_new_object_name VARCHAR2(50);
    v_sql VARCHAR2(4000);
	v_count INTEGER;
    v_current_datetime VARCHAR2(30);
BEGIN
	-- Формирование имени нового объекта
	SELECT TO_CHAR(SYSDATE, 'YYYY_MM_DD_HH24_MI_SS') INTO v_current_datetime FROM DUAL;
    v_new_object_name := p_source_table || '_' || p_object_type || '_' || v_current_datetime;
	DBMS_OUTPUT.PUT_LINE(v_new_object_name);

    -- Проверка существования объекта в словаре данных
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM user_objects WHERE object_name = UPPER(:1)' INTO v_count USING v_new_object_name; -- :1 - IT'S PLACEHOLDER FOR VARIABLE v_new_object_name
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Ошибка при проверке существования объекта: ' || SQLERRM);
            RETURN;
    END;

    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Объект с именем ' || v_new_object_name || ' уже существует.');
        RETURN;
    END IF;

    -- Создание нового объекта
    v_sql := 'CREATE ' || p_object_type || ' ' || v_new_object_name || ' AS SELECT ' || p_columns || ' FROM ' || p_source_table || ' WHERE ROWNUM <= ' || TO_CHAR(p_row_count);

    BEGIN
        EXECUTE IMMEDIATE v_sql;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Ошибка при создании объекта: ' || SQLERRM);
            RETURN;
    END;

    DBMS_OUTPUT.PUT_LINE('Объект ' || v_new_object_name || ' успешно создан.');
END;
/

____TESTING____:
BEGIN
    six_two_CreateNewObject('TABLE', 'Orders', 'ORD_SHIPPING_COST, ONLY_SENDER_NAME, ONLY_SENDER_SURNAME, ONLY_SENDER_PATRONYMIC', 10);
END;
/
____END____.


____TASK____: 
6.3.1
Создать процедуру, которая принимает в качестве параметров имя таблицы и имена четырех полей в этой таблице. 
Первое поле она интерпретирует как ФИО, разбивает его на составляющие и заполняет три оставшихся поля. Если 
значение первого поля не может быть правильно проинтерпретировано как ФИО (отсутствует отчество, имя и отчество 
или в строке встречаются недопустимые символы), она помещает в первое поле из трех оставшихся значения ключа 
(ROWID) этой записи, а во втором и третьем выводит соответствующее сообщение об ошибке строчными и прописными 
буквами.
____CODE____:

ALTER TABLE orders 
ADD ( only_sender_name VARCHAR2(50), 
only_sender_surname VARCHAR2(50), 
only_sender_patronymic VARCHAR2(50));

---my---
CREATE OR REPLACE PROCEDURE SplitFullName(
    p_table_name IN VARCHAR2,
    p_full_name_field IN VARCHAR2,
    p_first_name_field IN VARCHAR2,
    p_last_name_field IN VARCHAR2,
    p_patronymic_field IN VARCHAR2
) AS
    v_sql VARCHAR2(4000);
BEGIN
    v_sql := 'DECLARE
        CURSOR c IS SELECT ROWID, ' || p_full_name_field || ' FROM ' || p_table_name || ';
        v_full_name VARCHAR2(100);
        v_first_name VARCHAR2(100);
        v_last_name VARCHAR2(100);
        v_patronymic VARCHAR2(100);
        v_rowid ROWID;
    BEGIN
        FOR r IN c LOOP
            v_full_name := r.' || p_full_name_field || ';


			IF REGEXP_SUBSTR(v_full_name, ''[^a-zA-Z ]+'', 1, 1) IS NULL AND REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 4) IS NULL AND
					REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 1) IS NOT NULL AND REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 2) IS NOT NULL AND 
					REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 3) IS NOT NULL AND LENGTH(REGEXP_SUBSTR(v_full_name,''[^ ]+'', 1, 1)) > 3 AND 
					LENGTH(REGEXP_SUBSTR(v_full_name,''[^ ]+'', 1, 2)) > 3 AND LENGTH(REGEXP_SUBSTR(v_full_name,''[^ ]+'', 1, 3)) > 3 THEN 	
                v_first_name := REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 1);
                v_last_name := REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 2);
                v_patronymic := REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 3);
			ELSIF REGEXP_SUBSTR(v_full_name, ''[^a-zA-Z ]+'', 1, 1) IS NOT NULL THEN
				v_first_name := v_rowid;
                v_last_name := ''there are invalid characters in the fio'';
                v_patronymic := ''THERE ARE INVALID CHARACTERS IN THE FIO'';
			ELSIF REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 4) IS NOT NULL THEN
				v_first_name := v_rowid;
                v_last_name := ''the fio contains more than 3 words'';
                v_patronymic := ''THE FIO CONTAINS MORE THAN 3 WORDS'';
			ELSIF REGEXP_SUBSTR(v_full_name, ''[a-zA-Z]+'', 1, 3) IS NULL THEN
				v_first_name := v_rowid;
                v_last_name := ''the fio contains less than 3 words'';
                v_patronymic := ''THE FIO CONTAINS LESS THAN 3 WORDS'';
			ELSIF LENGTH(REGEXP_SUBSTR(v_full_name,''[^ ]+'', 1, 1)) < 4 THEN
				v_first_name := v_rowid;
                v_last_name := ''name is too short'';
                v_patronymic := ''NAME IS TOO SHORT'';
			ELSIF LENGTH(REGEXP_SUBSTR(v_full_name,''[^ ]+'', 1, 2)) < 4 THEN
				v_first_name := v_rowid;
                v_last_name := ''surname is too short'';
                v_patronymic := ''SURNAME IS TOO SHORT'';
			ELSIF LENGTH(REGEXP_SUBSTR(v_full_name,''[^ ]+'', 1, 3)) < 4 THEN
				v_first_name := v_rowid;
                v_last_name := ''patronymic is too short'';
                v_patronymic := ''PATRONYMIC IS TOO SHORT'';
			ELSE 
			    v_first_name := v_rowid;
                v_last_name := ''invalid value of full name'';
                v_patronymic := ''INVALID VALUE OF FULL NAME'';
			END IF;

			v_rowid := r.ROWID;

            EXECUTE IMMEDIATE ''UPDATE ' || p_table_name || ' SET ' || p_first_name_field || ' = :1, ' || p_last_name_field || ' = :2, ' || p_patronymic_field || ' = :3 WHERE ROWID = :4'' USING v_first_name, v_last_name, v_patronymic, v_rowid;

		END LOOP;		
    END;';

    EXECUTE IMMEDIATE v_sql;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);
END;
/

--------

____TESTING____:

BEGIN
    SplitFullName('Orders_TABLE_New', 'ORD_SENDER_NAME', 'ONLY_SENDER_NAME', 'ONLY_SENDER_SURNAME', 'ONLY_SENDER_PATRONYMIC');
END;
/
COMMIT;

----------------------------------------------------------------примеры
SELECT
  REGEXP_SUBSTR('500 Oracle Parkway, R,edwood Shores, CA',
                ',[^e]+,') "REGEXPR_SUBSTR"
  FROM DUAL;

шаблон представляет собой следующее: нужно найти подстроки, которые
обязательно начинаются и заканчиваются запятой, и которые не содержат в себе
ни одно 'e'. [^e] - значит не соответствие с символом в строке, т.е. 'e' нам не надо, а
+ значит одно или более вхождений, т.е. одно или более вхождений без 'e'

SELECT
  REGEXP_SUBSTR('500 Oracle Parkway,s, Redwood Shores, CA',
                ',[^dsf],') "REGEXPR_SUBSTR"
  FROM DUAL;

шаблон гласит, что должна быть найдена подстрока, с одним символом между двумя запятыми,
при этом этот символ не должен равнять d, s или f.

а вот так, SELECT
  REGEXP_SUBSTR('500 Oracle Parkway,s, Redwood Shores, CA',
                ',[^df],') "REGEXPR_SUBSTR"
  FROM DUAL; найдется символ и запятые
  
пример:SELECT
  REGEXP_SUBSTR('500 Oracle Parkway,s, Redwood Shores, CA',
                '[^ ]+', 1, 3) "REGEXPR_SUBSTR"
  FROM DUAL;

в результате будет "Parkway,s,", т.к. требуется 3-е вхождение маски, отсчет с начала строки
----------------------------------------------------------------примеры
____END____.


____TASK____:
6.4
Написать программу, которая позволит для двух указанных в параметрах таблиц существующей 
БД определить, есть ли между ними связь «один ко многим». Если связь есть, то на основе 
родительской таблицы создать новую, в которой будут присутствовать все поля старой и одно 
новое поле с типом коллекции, в котором при переносе данных помещаются все связанные 
записи из дочерней таблицы.
____CODE____:

проблема - каким-то образом, мне нужно создать тип данных, такой как в дочерней таблице.
но, при этом, чтобы это сделать. стоп. сейчас

------------------
тогда мне нужно извлечь все имена столбцов из таблицы orders и используя их определить тип данных.
для начала массив заполнить именами столбцов таблицы, а потом постепенно извлекая данные из массива
создать запрос на создание типа данных.

типо, потом динамически создать тип данных as object.., на основании его сделать таблицу типа этого типа object,
и потом попытаться этот тип данных запушить в ту новую таблицу

OK. МНЕ НУЖНО СДЕЛАТЬ ЧТО-ТО ТАКОЕ 

-------ЧТО-ТО ДЕЛАЛ, ОСТАВЛЮ НА ВСЯКИЙ_НАЧАЛО
CREATE OR REPLACE TYPE orders_row AS OBJECT (
ORDER_NUM orders.ORDER_NUM%ROWTYPE);
/

	CREATE OR REPLACE TYPE col_type AS OBJECT (name VARCHAR2(100));
	/
	
	CREATE OR REPLACE TYPE table_type AS table of col_type;
	/
	
DECLARE 
	columns_var table_type := table_type();
	column_value varchar2(100);
	child_table_name varchar2(50) := 'ORDERS';
	
	-- columns_var_index := columns_var.FIRST;	
	
	-- p_having_counter := 0;

	TYPE parts_table IS TABLE OF ORDERS%ROWTYPE;
	
BEGIN	
	FOR r IN (SELECT column_name FROM all_tab_columns
			WHERE table_name = child_table_name AND OWNER = USER) LOOP

        column_value := r.column_name;
        
		columns_var.EXTEND;
		columns_var(columns_var.LAST) := col_type(column_value);
    END LOOP;
	
	FOR i IN columns_var.FIRST..columns_var.LAST LOOP
        DBMS_OUTPUT.PUT_LINE('Key: ' || i || ', Value: ' || columns_var(i).name);
    END LOOP;
	


-- -----SELECT
-- WHILE columns_var_index IS NOT NULL LOOP
    -- -- access the array element
		
	-- -- ПРИ ПОМОЩИ dbms_output ПРОВЕРИТЬ С КАКОГО ЧИСЛА НАЧИНАЕТСЯ ОТСЧЕТ: начало с единицы
	-- IF columns_var_index = p_number_of_count_column_in_select then
		-- sqltext:= sqltext || space_comma || 'to_char(' || count_word || p_column_to_select(p_column_to_select_index) || right_bracket || ')';
		-- space_comma := ', ';
	-- ELSE 	
		-- sqltext := sqltext || space_comma || 'to_char(' || p_column_to_select(p_column_to_select_index) || ')';
		-- space_comma := ', ';	
	-- END IF;
	
	-- list_col.EXTEND;
	-- list_col(list_col.LAST).name := p_column_to_select(p_column_to_select_index);

    -- p_column_to_select_index := p_column_to_select.NEXT(p_column_to_select_index);
-- END LOOP;

end;
/
-------ЧТО-ТО ДЕЛАЛ, ОСТАВЛЮ НА ВСЯКИЙ_КОНЕЦ
----------------
r_constraint_name - Name of the unique constraint definition for the referenced table

-- если у таблицы две связи один ко многим, то могут быть ошибки
-- типо, таблица может быть и одна, но столбцов несколько
DECLARE
    first_table_name VARCHAR2(100) := 'DEPARTURE';
    second_table_name VARCHAR2(100) := 'BASKET';

	one_to_many_flag number := 0;

    parent_table_name VARCHAR2(100);
    child_table_name VARCHAR2(100);
    
	child_table_type VARCHAR2(100);
	
    v_ddl_for_object VARCHAR2(4000); 
    v_ddl_for_table VARCHAR2(4000); 

	new_table_name varchar2(100);

	child_r_constraint_name varchar2(100);
	
	-- child_table_column_conn varchar2(100);
	parent_table_column_conn varchar2(100);
	
	-- child_constraint_name varchar2(100);
	parent_constraint_name varchar2(100);

	object_type varchar2(100);
	type_to_check varchar2(100);
	check_value integer := 0;
	check_sql varchar2(300);
	drop_sql varchar2(300);
	
	sql_transfer varchar2(1000);
	
	nested_table_sql varchar2(1000);
	nested_check_value integer := 0;
	
	list_of_columns varchar2(1000);
	
    TYPE varchar2_collection IS TABLE OF VARCHAR2(4000); 
    child_r_constraint_names varchar2_collection;
	child_constraint_name varchar2_collection;
	child_table_column_conn varchar2_collection := varchar2_collection();
	
BEGIN
  -- Проверка наличия связи "один ко многим"
	BEGIN
		SELECT r_constraint_name
		BULK COLLECT INTO child_r_constraint_names
		FROM all_constraints
		WHERE r_constraint_name IN (
		SELECT constraint_name
		FROM all_constraints
		WHERE table_name = first_table_name
		  )
		AND table_name = second_table_name AND OWNER = USER;
		
		FOR i IN 1..child_r_constraint_names.COUNT LOOP
			one_to_many_flag := 1;
		END LOOP;
		
		EXCEPTION
			when no_data_found then
			null;
	END;
	
	if one_to_many_flag = 0 then
		SELECT r_constraint_name
		BULK COLLECT INTO child_r_constraint_names
		FROM all_constraints
		WHERE r_constraint_name IN (
		SELECT constraint_name
		FROM all_constraints
		WHERE table_name = second_table_name
		  )
		AND table_name = first_table_name AND OWNER = USER;

		FOR i IN 1..child_r_constraint_names.COUNT LOOP
			one_to_many_flag := 2;
		END LOOP;
	end if;

	if one_to_many_flag = 0 then
		RAISE no_data_found;
	end if;
	
	FOR i IN 1..child_r_constraint_names.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(child_r_constraint_names(i));
	END LOOP;
	
	if one_to_many_flag = 1 then
		parent_table_name := first_table_name;
		child_table_name := second_table_name;
	else 
		parent_table_name := second_table_name;
		child_table_name := first_table_name;
	end if;		
	
	dbms_output.PUT_LINE('PARENT:');
	dbms_output.PUT_LINE(parent_table_name);
	dbms_output.PUT_LINE('CHILD:');
	dbms_output.PUT_LINE(child_table_name);

	IF child_r_constraint_names is not null THEN

		object_type := child_table_name || '_OBJ';
		-- проверка существования типа(типа таблицы), т.к. если он есть, нельзя будет replace-нуть orders_obj
		type_to_check := child_table_name || '_TAB';
		
		check_sql := 'SELECT 1 
		FROM ALL_OBJECTS
		WHERE OWNER = USER AND OBJECT_NAME = ''' || type_to_check || '''';
			
		BEGIN
			EXECUTE IMMEDIATE check_sql into check_value;
			EXCEPTION
				when no_data_found then
					check_value := 0;
		END;
		
		dbms_output.PUT_LINE(check_value);

		IF check_value = 0 THEN
				-- drop_sql := 'DROP TYPE ' || type_to_check;
				-- DBMS_OUTPUT.PUT_LINE(drop_sql);
				-- EXECUTE IMMEDIATE drop_sql;
			-- END IF;

			-- создаем тип данных типа дочерней таблицы, чтобы его можно было вставить в новую таблицу родителя
			SELECT
				'CREATE OR REPLACE TYPE ' || table_name || '_OBJ IS OBJECT (' ||
				LISTAGG(
					column_name || ' ' ||
					CASE data_type
						WHEN 'NUMBER' THEN 'NUMBER(' || data_length || ',' || data_scale || ')'
						WHEN 'VARCHAR2' THEN 'VARCHAR2(' || data_length || ')'
						WHEN 'CHAR' THEN 'CHAR(' || data_length || ')'
						ELSE data_type
					END, ',' || chr(10)
				) WITHIN GROUP (ORDER BY column_id) || ');'
			INTO v_ddl_for_object
			FROM user_tab_cols
			WHERE table_name = child_table_name AND column_name NOT LIKE 'SYS_%'
			GROUP BY table_name;

			SELECT
				'CREATE OR REPLACE TYPE ' || table_name || '_TAB IS TABLE OF ' || table_name || '_OBJ;'
			INTO v_ddl_for_table
			FROM user_tab_cols
			WHERE table_name = child_table_name
			GROUP BY table_name;

			-- Теперь можно выполнить DDL-запросы
			EXECUTE IMMEDIATE v_ddl_for_object;

			EXECUTE IMMEDIATE v_ddl_for_table;
			
		END IF;

		child_table_type := child_table_name || '_TAB';
		
		-- Если связь есть, создаем новую таблицу
		new_table_name := parent_table_name || '_' || child_table_name || '_new_six_four';
				
		--Надо проверить, если таблица с таким названием, если да, то..., если нет, то ... удалять ничего не надо
		
		check_sql := 'SELECT 1 
		FROM ALL_OBJECTS
		WHERE OWNER = USER AND OBJECT_NAME = ''' || UPPER(new_table_name) || '''';
			
		BEGIN
			EXECUTE IMMEDIATE check_sql into check_value;
			EXCEPTION
				when no_data_found then
					check_value := 0;
		END;

		dbms_output.PUT_LINE(check_value);

		dbms_output.PUT_LINE(new_table_name);
		dbms_output.PUT_LINE('CREATE TABLE ' || UPPER(new_table_name) || ' AS SELECT * FROM ' || parent_table_name);

		dbms_output.PUT_LINE('ALTER TABLE ' || UPPER(new_table_name) || ' ADD (' || child_table_name || '_data ' || child_table_type || ') NESTED TABLE ' || child_table_name || '_data STORE AS ' || child_table_name || '_' || parent_table_name || '_data_tab');
   

		IF check_value = 0 THEN
			EXECUTE IMMEDIATE 'CREATE TABLE ' || UPPER(new_table_name) || ' AS SELECT * FROM ' || parent_table_name;
			-- Добавляем новое поле с типом коллекции
			-- EXECUTE IMMEDIATE 'ALTER TABLE ' || UPPER(new_table_name) || ' ADD (' || child || '_data ' || child_table_type || ')'; -- возможно здесь будет oracle ругаться на тип данных
			-- ПОКА НЕ ДОШЛИ ДО ПОСЛЕДНЕГО ОГРАНИЧЕНИЯ, ДОБАВЛЯЕМ СТОЛБЦЫ			
			FOR i IN 1..child_r_constraint_names.COUNT LOOP
				EXECUTE IMMEDIATE 'ALTER TABLE ' || UPPER(new_table_name) || ' ADD (' || parent_table_name || '_' || child_table_name || '_data_'  || i || ' ' || child_table_type || ') NESTED TABLE ' || parent_table_name || '_' || child_table_name || '_data_' || i || ' STORE AS ' || parent_table_name || '_' || child_table_name || '_data_tab' || i;
				DBMS_OUTPUT.PUT_LINE(i);
			END LOOP;
		END IF;
			
		SELECT
		LISTAGG( column_name || ', ') WITHIN GROUP (ORDER BY column_id) 
		INTO list_of_columns
		FROM user_tab_cols
		WHERE table_name = child_table_name AND column_name NOT LIKE 'SYS_%'
		GROUP BY table_name;
		
		-- сейчас удалим последнюю запятую
		
		list_of_columns := SUBSTR(list_of_columns, 1, LENGTH(list_of_columns) - 2);

		DBMS_OUTPUT.PUT_LINE(list_of_columns);
		
-- мне осталось только на основании поиска foreign ограничений, вот этого, ты понял, найти столбцы, за которыми закреплены эти ограничения
-- Я МОГУ НАЙТИ ОДНО ОГРАНИЧЕНИЕ. НА ОСНОВАНИИ ЕГО НАЙТИ СТОЛБЕЦ В ТАБЛИЦЕ, ГДЕ ЭТО ОГРАНИЧЕНИЕ, А ПОТОМ НА ОСНОВАНИИ
-- ЭТОГО ЖЕ ОГРАНИЧЕНИЯ НАЙТИ СТОЛБЕЦ В ДРУГОЙ ТАБЛИЦЕ, ДЕТСКОЙ

		SELECT distinct r_constraint_name
		INTO parent_constraint_name
		FROM all_constraints
		WHERE r_constraint_name IN (
		SELECT constraint_name
		FROM all_constraints
		WHERE table_name = parent_table_name 
		  )
		AND table_name = child_table_name AND OWNER = USER;
					
		SELECT COLUMN_NAME
		INTO parent_table_column_conn
		FROM ALL_CONS_COLUMNS
		WHERE TABLE_NAME = parent_table_name AND OWNER = USER AND CONSTRAINT_NAME = parent_constraint_name;

		DBMS_OUTPUT.PUT_LINE(parent_table_column_conn);

		SELECT constraint_name
		BULK COLLECT INTO child_constraint_name
		FROM all_constraints
		WHERE r_constraint_name = parent_constraint_name AND OWNER = USER and table_name = child_table_name ;
		
		FOR i IN 1..child_constraint_name.COUNT LOOP
			DBMS_OUTPUT.PUT_LINE(child_constraint_name(i));
		END LOOP;
		
		FOR i IN 1..child_constraint_name.COUNT LOOP
			child_table_column_conn.extend;
			SELECT COLUMN_NAME
			INTO child_table_column_conn(i)
			FROM ALL_CONS_COLUMNS
			WHERE TABLE_NAME = child_table_name AND OWNER = USER AND CONSTRAINT_NAME = child_constraint_name(i);
		END LOOP;
		
		FOR i IN 1..child_table_column_conn.COUNT LOOP
			DBMS_OUTPUT.PUT_LINE(child_table_column_conn(i));
		END LOOP;

-- я получил названия столбцов таблице orders, которые foreign key для branch, и я могу пушить данные

		-- dbms_output.PUT_LINE(parent_table_column_conn);
		-- dbms_output.PUT_LINE(child_table_column_conn);

		-- надо сделать так, чтобы то, что после ковычек заработало, а потом уже составлять текст, чтобы можно было execute IMMEDIATE
			--Переносим данные
			FOR i IN 1..child_table_column_conn.COUNT LOOP
				sql_transfer := 'DECLARE v_' || child_table_name || ' ' || type_to_check || ';
				BEGIN 
				FOR r IN (SELECT ' || parent_table_column_conn || ' FROM ' || parent_table_name || ') LOOP
				SELECT ' || object_type || '(' || list_of_columns || ')' || '
				BULK COLLECT INTO v_' || child_table_name || '
				  FROM ' || child_table_name || '
				  WHERE ' || child_table_column_conn(i) || ' = r.' || parent_table_column_conn || ';
				  
				  UPDATE ' || UPPER(new_table_name) || '
				  SET ' || parent_table_name || '_' || child_table_name || '_data_' || i || ' = v_' || child_table_name || '
				  WHERE ' || parent_table_column_conn || ' = r.' || parent_table_column_conn || ';
				END LOOP;
				END;';

				
				dbms_output.PUT_LINE(sql_transfer);

				EXECUTE IMMEDIATE sql_transfer;
			END LOOP;


			--Переносим данные
			-- FOR r IN (SELECT * FROM parent_table_name) LOOP
			  -- SELECT *
			  -- BULK COLLECT INTO v_collection
			  -- FROM p_child_table_name
			  -- WHERE foreign_key = r.primary_key;
			  
			  -- UPDATE new_table_name
			  -- SET child_records = v_collection
			  -- WHERE primary_key = r.primary_key;
			-- END LOOP;
  END IF;
	
	EXCEPTION
		when no_data_found then
			dbms_output.PUT_LINE('there is no one-to-many relationship between the tables');

END;
/

____TESTING____:
как селектить коллекцию из таблицы?
SELECT GEARBOX_VEHICLE_DATA_1 FROM table(cast(GEARBOX_VEHICLE_NEW_SIX_FOUR)) ;

FUNCTION objects_print 
   RETURN VEHICLE_TAB 
IS
   -- l_count PLS_INTEGER;
   ADS VEHICLE_TAB := VEHICLE_TAB();
BEGIN
	-- SELECT count(*) into obj_count
	 -- FROM GEARBOX_VEHICLE_NEW_SIX_FOUR;
   ADS := VEHICLE_TAB();

	SELECT GEARBOX_VEHICLE_DATA_1 
	BULK COLLECT INTO ADS
	FROM GEARBOX_VEHICLE_NEW_SIX_FOUR;

	-- while obj_count > 0 loop
	-- end loop;
	
   -- extend_assign (dad_in); 
   -- extend_assign (mom_in);
   RETURN retval; 
END;
/

FUNCTION objects_print RETURN VEHICLE_TAB IS
   retval VEHICLE_TAB := VEHICLE_TAB(); -- Объявляем пустой массив

BEGIN
   SELECT GEARBOX_VEHICLE_DATA_1 
   INTO retval
   FROM GEARBOX_VEHICLE_NEW_SIX_FOUR;

   -- Другие действия с retval...

   RETURN retval; 
END;
/

BEGIN
    create_collection_table('STAFF', 'ORDERS');
END;
/
COMMIT;


  SELECT *
  FROM all_constraints
  WHERE r_constraint_name IN (
    SELECT constraint_name
    FROM all_constraints
    WHERE table_name = 'BRANCH'
  )
  AND table_name = 'ORDERS' AND OWNER = USER;


____END____.






--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
Триггер: Процедура, которая будет предоставлять скидку на сумму заказа:
при отправке товаров весом более 100 кг, дополнительные 5 килограмм можно отправить 
бесплатно. То есть, если вес груза больше 100 килограмм, то мы делим вес груза на 
стоимость доставки и умножаем это число на (масса груза – 5 киллограм).
если масса груза > 100 и < 200 кило, то бесплатно 5 кг
если масса груза > 200 и < 300 кило, то бесплатно 15 кг
если масса груза > 300 и < 400 кило, то бесплатно 25 кг
если масса груза > 500 и < 600 кило, то бесплатно 35 кг
если масса груза > 600 и < 700 кило, то бесплатно 45 кг
если груз больше 700 кило, то мы не принимаем такой заказ - ввести ограничение в таблицу.






-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
----------------------------------изменения после 18.09 парыы------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------


alter table Positions
drop column PST_employee_availability;

alter table Positions
drop column PST_english_A2_required;

alter table Positions
drop column PST_driver_license;

alter table Positions
add PST_employee_availability VARCHAR2(3);

alter table Positions
add PST_english_A2_required VARCHAR2(3);

alter table Positions
add PST_driver_license VARCHAR2(3);


					PST_employee_availability VARCHAR2(3) NOT NULL,
					PST_driver_license VARCHAR2(3) NOT NULL,
					PST_english_A2_required VARCHAR2(3) NOT NULL,

update Positions
set PST_employee_availability = 'No'
where Position_code = 1;

update Positions
set PST_employee_availability = 'Yes'
where Position_code = 2;

update Positions
set PST_employee_availability = 'No'
where Position_code = 3;

update Positions
set PST_employee_availability = 'No'
where Position_code = 4;

update Positions
set PST_employee_availability = 'Yes'
where Position_code = 5;
-----
update Positions
set PST_driver_license = 'No'
where Position_code = 1;

update Positions
set PST_driver_license = 'No'
where Position_code = 2;

update Positions
set PST_driver_license = 'Yes'
where Position_code = 3;

update Positions
set PST_driver_license = 'Yes'
where Position_code = 4;

update Positions
set PST_driver_license = 'No'
where Position_code = 5;
----
update Positions
set PST_english_A2_required = 'No'
where Position_code = 1;

update Positions
set PST_english_A2_required = 'Yes'
where Position_code = 2;

update Positions
set PST_english_A2_required = 'Yes'
where Position_code = 3;

update Positions
set PST_english_A2_required = 'No'
where Position_code = 4;

update Positions
set PST_english_A2_required = 'Yes'
where Position_code = 5;
-----

----------------------------------------------------

alter table Vehicles_sellers
drop column SLR_cars_num_bought_from_this_seller;

alter table Vehicles_sellers
drop column SLR_sales_launch_year;

------------
alter table Positions
modify (PST_employee_availability NOT NULL);

alter table Positions
modify (PST_driver_license NOT NULL);

alter table Positions
modify (PST_english_A2_required NOT NULL);

-------------------------------------------
alter table orders
drop column ORD_fragile;

alter table orders
add ORD_fragile VARCHAR2(3);

update orders
set ORD_fragile = 'Yes'
where Order_num = 7;

update orders
set ORD_fragile = 'No'
where Order_num = 12;

update orders
set ORD_fragile = 'No'
where Order_num = 10;

update orders
set ORD_fragile = 'No'
where Order_num = 4;

update orders
set ORD_fragile = 'No'
where Order_num = 5;

update orders
set ORD_fragile = 'No'
where Order_num = 6;

update orders
set ORD_fragile = 'No'
where Order_num = 7;

update orders
set ORD_fragile = 'No'
where Order_num = 8;

update orders
set ORD_fragile = 'No'
where Order_num = 9;

update orders
set ORD_fragile = 'Yes'
where Order_num = 10;

update orders
set ORD_fragile = 'Yes'
where Order_num = 11;

update orders
set ORD_fragile = 'No'
where Order_num = 12;

update orders
set ORD_fragile = 'No'
where Order_num = 13;

alter table orders
modify (ORD_fragile NOT NULL);
--------------------------------------------------------------
alter table orders
drop column ORD_completeness_check;

alter table orders
add ORD_completeness_check VARCHAR2(3);

update orders
set ORD_completeness_check = 'No'
where Order_num = 1;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 2;

update orders
set ORD_completeness_check = 'No'
where Order_num = 3;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 4;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 5;

update orders
set ORD_completeness_check = 'No'
where Order_num = 6;

update orders
set ORD_completeness_check = 'No'
where Order_num = 7;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 8;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 9;

update orders
set ORD_completeness_check = 'No'
where Order_num = 10;

update orders
set ORD_completeness_check = 'No'
where Order_num = 11;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 12;

update orders
set ORD_completeness_check = 'Yes'
where Order_num = 13;

alter table orders
modify (ORD_completeness_check NOT NULL);
------------------------------------------------------------
alter table orders
drop column ORD_cash_payment;

alter table orders
add ORD_cash_payment VARCHAR2(3);

update orders
set ORD_cash_payment = 'Yes'
where Order_num = 1;

update orders
set ORD_cash_payment = 'No'
where Order_num = 2;

update orders
set ORD_cash_payment = 'No'
where Order_num = 3;

update orders
set ORD_cash_payment = 'Yes'
where Order_num = 4;

update orders
set ORD_cash_payment = 'Yes'
where Order_num = 5;

update orders
set ORD_cash_payment = 'Yes'
where Order_num = 6;

update orders
set ORD_cash_payment = 'No'
where Order_num = 7;

update orders
set ORD_cash_payment = 'No'
where Order_num = 8;

update orders
set ORD_cash_payment = 'Yes'
where Order_num = 9;

update orders
set ORD_cash_payment = 'Yes'
where Order_num = 10;

update orders
set ORD_cash_payment = 'No'
where Order_num = 11;

update orders
set ORD_cash_payment = 'No'
where Order_num = 12;

update orders
set ORD_cash_payment = 'No'
where Order_num = 13;

alter table orders
modify (ORD_cash_payment NOT NULL);
---------------------------------------------------BASKET---------------------------------------------------

delete from basket where Departure_num = 1;
delete from basket where Departure_num = 2;
delete from basket where Departure_num = 3;
delete from basket where Departure_num = 4;
delete from basket where Departure_num = 5;


alter table basket 
add Basket_code INTEGER generated by default as identity(nocache);

alter table basket 
ADD CONSTRAINT basket_primary PRIMARY KEY (Basket_code);


begin
insert into Basket(Departure_num, Order_num) values(1,3);
insert into Basket(Departure_num, Order_num) values(2,5);
insert into Basket(Departure_num, Order_num) values(2,1);
insert into Basket(Departure_num, Order_num) values(3,2);
insert into Basket(Departure_num, Order_num) values(3,4);
insert into Basket(Departure_num, Order_num) values(3,6);
insert into Basket(Departure_num, Order_num) values(4,7);
insert into Basket(Departure_num, Order_num) values(1,9);
insert into Basket(Departure_num, Order_num) values(1,10);
insert into Basket(Departure_num, Order_num) values(1,11);
insert into Basket(Departure_num, Order_num) values(1,12);
insert into Basket(Departure_num, Order_num) values(5,13);
end;
/






//////////////////////////////////////////////////////
на всякий случай
CREATE TABLE aux_table(aux_Order_num INTEGER CONSTRAINT aux_order_number UNIQUE,
					aux_ORD_sender_name VARCHAR2(40) NOT NULL,
					aux_ORD_sender_address VARCHAR2(50) NOT NULL,
					aux_ORD_sender_phone CHAR(17) NOT NULL,
					aux_ORD_sending_office INTEGER NOT NULL,
					aux_ORD_employee_placing_the_order_num INTEGER NOT NULL,
					aux_ORD_package_weight DECIMAL(20,3) NOT NULL,
					aux_ORD_package_scope DECIMAL(20,3) NOT NULL,
					aux_ORD_package_receipt_date DATE NOT NULL,
					aux_ORD_declared_value_amount DECIMAL(30,3),
					aux_ORD_cash_on_dlvry_amount DECIMAL(30,3),
                    aux_ORD_arrival_date DATE,
					aux_ORD_recipient_name VARCHAR2(40) NOT NULL,
					aux_ORD_recipient_address VARCHAR2(50) NOT NULL,
					aux_ORD_recipient_phone CHAR(17) NOT NULL,
					aux_ORD_receiving_office INTEGER NOT NULL,
					aux_ORD_shipping_cost DECIMAL(30,3) NOT NULL,
					aux_ORD_deliv_type_code INTEGER NOT NULL,
					aux_ORD_fragile VARCHAR2(3) NOT NULL,
					aux_ORD_completeness_check VARCHAR2(3) NOT NULL,
					aux_ORD_cash_payment VARCHAR2(3) NOT NULL
);

CREATE OR REPLACE PROCEDURE copy_orders_to_aux_table
AS
	cursor orders_cursor is
	select * 
	from orders 
	where ORD_package_receipt_date BETWEEN TRUNC(SYSDATE, 'MONTH') AND SYSDATE;
		
	p_Order_num INTEGER;
	p_ORD_sender_name VARCHAR2(40);
	p_ORD_sender_address VARCHAR2(50);
	p_ORD_sender_phone CHAR(17);
	p_ORD_sending_office INTEGER;
	p_ORD_employee_placing_the_order_num INTEGER;
	p_ORD_package_weight DECIMAL(20,3);
	p_ORD_package_scope DECIMAL(20,3);
	p_ORD_package_receipt_date DATE;
	p_ORD_declared_value_amount DECIMAL(30,3);
	p_ORD_cash_on_dlvry_amount DECIMAL(30,3);
	p_ORD_arrival_date DATE;
	p_ORD_recipient_name VARCHAR2(40);
	p_ORD_recipient_address VARCHAR2(50);
	p_ORD_recipient_phone CHAR(17);
	p_ORD_receiving_office INTEGER;
	p_ORD_shipping_cost DECIMAL(30,3);
	p_ORD_deliv_type_code INTEGER;
	p_ORD_fragile VARCHAR2(3);
	p_ORD_completeness_check VARCHAR2(3);
	p_ORD_cash_payment VARCHAR2(3);	
	
	exp_unique_id exception;
	PRAGMA EXCEPTION_INIT (exp_unique_id, -00001);

begin

	OPEN orders_cursor;
	
	--OPEN orders_cursor;

	loop 
		fetch orders_cursor into p_Order_num,p_ORD_sender_name,
		p_ORD_sender_address,p_ORD_sender_phone,p_ORD_sending_office,
		p_ORD_employee_placing_the_order_num,p_ORD_package_weight,
		p_ORD_package_scope,p_ORD_package_receipt_date,
		p_ORD_declared_value_amount,p_ORD_cash_on_dlvry_amount,
		p_ORD_arrival_date,p_ORD_recipient_name,p_ORD_recipient_address,
		p_ORD_recipient_phone,p_ORD_receiving_office,p_ORD_shipping_cost,
		p_ORD_deliv_type_code,p_ORD_fragile,p_ORD_completeness_check,
		p_ORD_cash_payment;
		exit when orders_cursor%NOTFOUND;
		
		insert into aux_table(aux_Order_num,aux_ORD_sender_name,
		aux_ORD_sender_address,aux_ORD_sender_phone,aux_ORD_sending_office,
		aux_ORD_employee_placing_the_order_num,aux_ORD_package_weight,
		aux_ORD_package_scope,aux_ORD_package_receipt_date,
		aux_ORD_declared_value_amount,aux_ORD_cash_on_dlvry_amount,
		aux_ORD_arrival_date,aux_ORD_recipient_name,aux_ORD_recipient_address,
		aux_ORD_recipient_phone,aux_ORD_receiving_office,
		aux_ORD_shipping_cost,aux_ORD_deliv_type_code,aux_ORD_fragile,
		aux_ORD_completeness_check,aux_ORD_cash_payment)
		values (p_Order_num, p_ORD_sender_name, p_ORD_sender_address,
		p_ORD_sender_phone,	p_ORD_sending_office, p_ORD_employee_placing_the_order_num,
		p_ORD_package_weight, p_ORD_package_scope, p_ORD_package_receipt_date, 
		p_ORD_declared_value_amount, p_ORD_cash_on_dlvry_amount, p_ORD_arrival_date, 
		p_ORD_recipient_name, p_ORD_recipient_address, p_ORD_recipient_phone, 
		p_ORD_receiving_office,	p_ORD_shipping_cost, p_ORD_deliv_type_code, 
		p_ORD_fragile, p_ORD_completeness_check, p_ORD_cash_payment);
	end loop;
		
		close orders_cursor;
		
		DBMS_OUTPUT.PUT_LINE('The lines have been copied successfully');
	
exception
	WHEN exp_unique_id THEN
	DBMS_OUTPUT.PUT_LINE ('Ошибка №' || sqlcode || ' заказ с номером ' || p_Order_num || ' уже существует'); 
	WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('За текущий месяцев не было сделано ни одного заказа');
	WHEN CURSOR_ALREADY_OPEN THEN
    DBMS_OUTPUT.PUT_LINE('Ошибка №' || sqlcode || '. Курсор уже открыт');
	when others then 
    DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);

END;
/