--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------5 LABA------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
1.	
____TASK____: Написать DML-триггер, регистрирующий изменение данных (вставку, обновление, удаление) в одной из таблиц БД. Во 
вспомогательную таблицу LOG1 записывать, кто, когда (дата и время) и какое именно изменение произвел, для одного из столбцов 
сохранять старые и новые значения.
____CODE____:

CREATE TABLE log1 (
    user_name VARCHAR2(255),
    change_type VARCHAR2(255),
    change_date TIMESTAMP,
    change_column VARCHAR2(255),
    old_value VARCHAR2(255),
    new_value VARCHAR2(255)
);

CREATE OR REPLACE TRIGGER log_orders_changes
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW
DECLARE 
	username VARCHAR2(255);
	current_timestamp TIMESTAMP;
	defined_column CHAR(15);
	changetype VARCHAR2(255);
BEGIN

    -- Получаем имя пользователя, который произвел изменение
	SELECT user INTO username
	FROM dual
	WHERE user = USER;

    -- Получаем дату и время изменения
	SELECT sysdate INTO current_timestamp
	from dual;

    -- Определяем тип изменения
	IF INSERTING THEN
		changetype := 'INSERT';
	ELSIF UPDATING THEN
		changetype := 'UPDATE';
	ELSE
		changetype := 'DELETE';
	END IF;

    -- Определяем столбец, для которого нужно сохранить старые и новые значения
	defined_column := 'ORD_sender_name';
	
    -- Сохраняем данные в вспомогательную таблицу
    INSERT INTO log1 (
        user_name,
        change_type,
        change_date,
        change_column,
        old_value,
        new_value
    ) VALUES (
        username,
        changetype,
        current_timestamp,
        defined_column,
        :OLD.ORD_sender_name,
        :NEW.ORD_sender_name
    );
END;
/
____TESTING____:
delete from orders where Order_num = 14;

UPDATE orders
SET ORD_sender_name = 'Lolita'
WHERE Order_num = 13;

UPDATE orders
SET ORD_recipient_name = 'Bukovski Charlse'
WHERE Order_num = 11;

insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_shipping_cost,ORD_deliv_type_code,ORD_cash_payment) values('Kanye West', 'Minsk, Tsarikova. 47','+375(44)511-12-12',2,5,400,0.01,DATE '2023-10-11',20,50,'Yes','No',NULL,'Tarasov P.P.','Brest, Marochkina str. 23','+375(44)511-21-23',3,518.40,1,'Yes');
____END____.

2.
____TASK____: 
Написать DDL-триггер, протоколирующий действия пользователей по созданию, изменению и 
удалению таблиц в схеме во вспомогательную таблицу LOG2 в определенное время и запрещающий 
эти действия в другое время.
____CODE____:

GRANT CREATE TRIGGER, ALTER TRIGGER TO iosu_labs;

-- CREATE TABLE log2 (
  -- id_log2 number GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1 NOCACHE),
  -- username VARCHAR2(255),
  -- action VARCHAR2(255),
  -- change_date TIMESTAMP,
  -- table_name VARCHAR2(255),
  -- statements varchar2(1000),
  -- primary key(id_log2)
-- );

CREATE TABLE log2 (
  id_log2 number GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1 NOCACHE),
  username VARCHAR2(255),
  action VARCHAR2(255),
  change_date TIMESTAMP,
  table_name VARCHAR2(255),
  primary key(id_log2)
);


CREATE OR REPLACE TRIGGER log_ddl_actions
BEFORE CREATE OR ALTER OR DROP ON SCHEMA
DECLARE 
    user_name VARCHAR2(255);
    current_timestamp TIMESTAMP;
	allowed_hours NUMBER;
	tble_name VARCHAR2(255);
	act VARCHAR2(255);
	
	-- sql_text ora_name_list_t;
	-- v_stmt   VARCHAR2(2000);
	-- n        PLS_INTEGER;
	
	-- correct_time exception;
	-- PRAGMA EXCEPTION_INIT (correct_time, -20000);

BEGIN

-- n := ora_sql_txt(sql_text);
-- FOR i IN 1 .. n LOOP
-- v_stmt := v_stmt || sql_text(i);
-- END LOOP;


-- v_stmt :=regexp_replace(v_stmt,
											   -- 'rename[[:space:]]+.*[[:space:]]+to[[:space:]]+([a-z0-9_]+)',
											   -- '\1',
											   -- 1,
											   -- 1,
											   -- 'i');

  -- Получаем имя пользователя, который произвел изменение
	SELECT USER	
	INTO user_name
	FROM dual;

	SELECT CURRENT_TIMESTAMP INTO current_timestamp
	from dual;
	
	SELECT ORA_SYSEVENT INTO act FROM dual;
		
    -- Получаем имя изменяемой таблицы
 
    SELECT ORA_DICT_OBJ_NAME INTO tble_name FROM dual;


    -- Проверяем, находится ли текущее время в разрешенном интервале
	SELECT TO_NUMBER(TO_CHAR(SYSDATE, 'HH24')) INTO allowed_hours FROM dual;

	IF allowed_hours NOT BETWEEN 8 AND 22 THEN
		RAISE_APPLICATION_ERROR(-20000, 'DDL is not permitted during this time');
	END IF;
  	
  -- Регистрируем действие в вспомогательной таблице
  INSERT INTO log2 (
    username,
    action,
    change_date,
    table_name
) VALUES (
    user_name,
    act,
    current_timestamp,
    tble_name
  );
  
  
-- EXCEPTION
  -- -- Обработка ошибки -20001
  -- WHEN correct_time THEN
    -- DBMS_OUTPUT.PUT_LINE('Операция DDL запрещена в нерабочее время.');
    -- DBMS_OUTPUT.PUT_LINE('Пользователь: ' || user_name);
    -- DBMS_OUTPUT.PUT_LINE('Время: ' || current_timestamp);
    -- DBMS_OUTPUT.PUT_LINE('Таблица: ' || tble_name);
    -- DBMS_OUTPUT.PUT_LINE('Тип действия: ' || act);

END;
/

ALTER TRIGGER log_ddl_actions ENABLE;
____TESTING____:

CREATE TABLE log4 (
  username VARCHAR2(255),
  action VARCHAR2(255),
  change_date TIMESTAMP,
  table_name VARCHAR2(255)
);

ALTER TABLE LOG4
ADD new_column varchar2(255);

DROP TABLE LOG4; 

-- DROP TABLE your_table PURGE;
-- SHOW RECYCLEBIN

alter trigger log_ddl_actions disable;
alter trigger log_ddl_actions enable;

____END____.


3.
____TASK____: 
Написать системный триггер, добавляющий запись во вспомогательную таблицу LOG3, когда пользователь 
подключается или отключается. В таблицу логов записывается имя пользователя (USER), тип активности 
(LOGON или LOGOFF), дата (SYSDATE), количество записей в основной таблице БД
____CODE____:
CREATE TABLE log3 (
  id_log3 number GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1 NOCACHE),
  usr_name VARCHAR2(30),
  activity VARCHAR2(10),
  cur_date TIMESTAMP,
  records_count NUMBER
);

CREATE OR REPLACE TRIGGER LOG_USER_LOGON
AFTER LOGON ON DATABASE
DECLARE
  username VARCHAR2(30);
  activity VARCHAR2(10);
  currentdate TIMESTAMP;
  records_count NUMBER;
BEGIN

  -- Получаем имя пользователя
  username := USER;

  -- Определяем тип активности
  activity := 'LOGON';

  -- Получаем текущую дату
  SELECT CURRENT_TIMESTAMP INTO currentdate
  from dual;

  -- Получаем количество записей в основной таблице
  SELECT COUNT(*) INTO records_count
  FROM orders;

  -- Регистрируем событие в вспомогательной таблице
  INSERT INTO log3 (usr_name, activity, cur_date, records_count)
  VALUES (username, activity, currentdate, records_count);

END;
/

-- Триггер отключения клиента
CREATE OR REPLACE TRIGGER LOG_USER_LOGOFF
BEFORE LOGOFF ON DATABASE
DECLARE
 username VARCHAR2(30);
 activity VARCHAR2(10);
 currentdate TIMESTAMP;
 records_count NUMBER;
BEGIN
 -- Получаем имя пользователя
 username := USER;

 -- Определяем тип активности
 activity := 'LOGOFF';

  -- Получаем текущую дату
  SELECT CURRENT_TIMESTAMP INTO currentdate
  from dual;

 -- Получаем количество записей в основной таблице
 SELECT COUNT(*) INTO records_count
 FROM orders;

 -- Регистрируем событие в вспомогательной таблице
 INSERT INTO log3 (usr_name, activity, cur_date, records_count)
 VALUES (username, activity, currentdate, records_count);

END;
/

____TESTING____:
exit
log on
____END____.


4.
____TASK____: 
	Написать триггеры, реализующие бизнес-логику (ограничения) в заданной 
вариантом предметной области. Три задания приведены в прил. 6. Количество 
и тип триггеров (строковый или операторный, выполняется AFTER или BEFORE) 
определять самостоятельно исходя из сути заданий и имеющейся схемы БД; учесть, 
что в некоторых вариантах первые два задания могут быть выполнены в рамках 
одного триггера, а также возможно возникновение мутации, что приведет к совмещению 
данного пункта лабораторной работы со следующим. 
	Третий пункт задания предполагает использование планировщика задач, 
который обязательно должен быть настроен на многократный запуск с использованием 
частоты, интервала и спецификаторов.

1)Осуществлять контроль загруженности курьеров, например, по количеству 
одновременно обслуживаемых подписчиков. 
2)Осуществлять расчет стоимости подписки, при этом предусматривать, 
чтобы нельзя было подписаться менее чем на месяц и более чем на год, 
а дата оформления подписки должна быть не позднее 10 дней до ее начала.
3)Каждый месяц перемещать подписки с законченным сроком в архив.

____TASK____: 
1+2. Расчет стоимости заказа исходя из переданных параметров заказа
+ скидка, если большой вес посылки
{
	№1.осуществлять расчет стоимости заказа:
		а)каждый килограмм = 1 руб, изначально (ограничение по весу от 0.1 до 700 кг
	alter table orders 
	add constraint orders_package_weight
	check (ORD_PACKAGE_WEIGHT < 700 and ORD_PACKAGE_WEIGHT > 0.1);
		б)каждая тысячная метра кубического объема 0.001 = 0.5 руб
	alter table orders 
	add constraint orders_package_scope
	check (ORD_package_scope < 10 and ORD_package_scope > 0.001);
		в)объявленная стоимость:
	alter table orders 
	add constraint orders_package_declared_value
	check (ORD_declared_value_amount < 10000 and ORD_declared_value_amount > 5);
	> 100 рублей, то общая стоимость доставки увеличивается на 5% от объявленной стоимости
	> 1000 рублей, то общая стоимость доставки увеличивается на 10% от объявленной стоимости
		г)наложенный платеж: -
		д)хрупкое:
	если да, то + 10% от объявленной стоимости
	если нет, то -
		е)проверка получателем товара:
	если да, то + 1 процент от объявленной стоимости
	если нет, то -
		ж)тип доставки:
	если курьер, то + 5% от объявленной стоимости
	если грузовик, то + 1% от объявленной стоимости
		з)тип оплаты:
	если безнал, то - 1% от объявленной стоимости
	если нал, то -
	
	ALTER TABLE orders
	MODIFY ORD_declared_value_amount not NULL;

	ALTER TABLE orders
	MODIFY ORD_shipping_cost NULL;
	
	alter table Orders
	modify ORD_shipping_cost DECIMAL(30,2); 

	ALTER TRIGGER CALCULATE_SHIPPING_COST enable;

	№2.при отправке товаров весом более 100 кг, дополнительные 5 килограмм можно отправить 
	бесплатно. То есть, если вес груза больше 100 килограмм, то мы делим стоимость доставки на 
	вес груза и умножаем это число на (масса груза – 5 киллограм).
	если масса груза > 100 и < 200 кило, то бесплатно 5 кг
	если масса груза > 200 и < 300 кило, то бесплатно 15 кг
	если масса груза > 300 и < 400 кило, то бесплатно 25 кг
	если масса груза > 500 и < 600 кило, то бесплатно 35 кг
	если масса груза > 600 и < 700 кило, то бесплатно 45 кг
	если груз больше 700 кило, то мы не принимаем такой заказ - ввести ограничение в таблицу.

}

____CODE____:
---------------------------------------------------
---------------------------------------------------
-----ТРИГГЕР НА ФОРМИРОВАНИЕ СТОИМОСТИ ЗАКАЗА------
---------------------------------------------------
---------------------------------------------------
CREATE OR REPLACE TRIGGER CALCULATE_SHIPPING_COST
BEFORE INSERT OR UPDATE ON Orders
FOR EACH ROW
DECLARE
  shipping_cost DECIMAL(30,2) default 0.0;
  courier_code INTEGER;
  truck_code INTEGER;

  birth_day number;
  birth_month number;
  today_day number;
  today_month number;

BEGIN
--------------------------
-- РАСЧЕТ СТОИМОСТИ ЗАКАЗА
--------------------------
		-- а)каждый килограмм = 0.5 руб, изначально (ограничение по весу от 0.1 до 700 кг
		
			shipping_cost := shipping_cost + :new.ORD_package_weight*0.5;
		
		-- б)каждая тысячная метра кубического объема 0.001 = 0.1 руб
		
			shipping_cost := shipping_cost + :new.ORD_package_scope*100;
		
		-- в)объявленная стоимость:
		
			if :new.ORD_declared_value_amount >= 100 and :new.ORD_declared_value_amount < 1000 then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			elsif :new.ORD_declared_value_amount >= 1000 then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.2;
			end if;
		
		-- г)наложенный платеж: -
		-- д)хрупкое:
		
			-- если да, то + 10% от объявленной стоимости
			-- если нет, то -
			if :new.ORD_fragile = 'Yes' then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			end if;
		
		-- е)проверка получателем товара:
			-- если да, то + 1 процент от объявленной стоимости
			-- если нет, то -
			if :new.ORD_completeness_check = 'Yes' then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			end if;
		
		-- ж)тип доставки:
			-- если курьер, то + 5% от объявленной стоимости
			-- если грузовик, то + 1% от объявленной стоимости
			select DLV_code into courier_code
			from Delivery_type where DLV_delivery_method = 'Courier';

			select DLV_code into truck_code
			from Delivery_type where DLV_delivery_method = 'Truck';

			if :new.ORD_deliv_type_code = courier_code then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.1;
			elsif :new.ORD_deliv_type_code = truck_code then
				shipping_cost := shipping_cost + :new.ORD_declared_value_amount*0.05;
			end if;
		
		-- з)тип оплаты:
			-- если безнал, то - 1% от объявленной стоимости
			-- если нал, то -
			if :new.ORD_cash_payment = 'No' then
				shipping_cost := shipping_cost - :new.ORD_declared_value_amount*0.01;
			end if;
--------------------------
-- СКИДКА ЗА ВЕС
--------------------------
	IF :new.ORD_PACKAGE_WEIGHT > 99 and :new.ORD_PACKAGE_WEIGHT < 200 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 5);
	elsif :new.ORD_PACKAGE_WEIGHT >= 200 and :new.ORD_PACKAGE_WEIGHT < 300 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 15);
	elsif :new.ORD_PACKAGE_WEIGHT >= 300 and :new.ORD_PACKAGE_WEIGHT < 400 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 25);
	elsif :new.ORD_PACKAGE_WEIGHT >= 400 and :new.ORD_PACKAGE_WEIGHT < 500 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 35);
	elsif :new.ORD_PACKAGE_WEIGHT >= 500 and :new.ORD_PACKAGE_WEIGHT < 600 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 45);
	elsif :new.ORD_PACKAGE_WEIGHT >= 600 and :new.ORD_PACKAGE_WEIGHT < 700 then
		shipping_cost := shipping_cost/:new.ORD_PACKAGE_WEIGHT * (:new.ORD_PACKAGE_WEIGHT - 50);
	end if;
	
	select EXTRACT(DAY FROM :new.ord_sender_birth_day) into birth_day from dual;
	select EXTRACT(MONTH FROM :new.ord_sender_birth_day) into birth_month from dual;
	select EXTRACT(DAY FROM sysdate) into today_day from dual;
	select EXTRACT(MONTH FROM sysdate) into today_month from dual;
--------------------------
-- ПРОВЕРКА НА ДЕНЬ РОЖДЕНИЯ
--------------------------
	if birth_day = today_day and birth_month = today_month then
		  shipping_cost := shipping_cost * 0.8;
	END IF;
--------------------------
		
  -- Устанавливаем стоимость доставки
  :new.ORD_shipping_cost := shipping_cost;
	dbms_output.put_line('BIRTH: ' || :new.ord_sender_birth_day);
	dbms_output.put_line('cost: ' || :new.ORD_shipping_cost);

	dbms_output.put_line('CELEBRATE');
END;
/

------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
____TESTING____:
1:
UPDATE orders
SET ORD_declared_value_amount = 200
WHERE order_num = 4;

insert into Orders(ORD_sender_name,ORD_sender_address,ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,ORD_declared_value_amount,ORD_cash_on_dlvry_amount,ORD_fragile,ORD_completeness_check,ORD_arrival_date,ORD_recipient_name,ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,ORD_deliv_type_code,ORD_cash_payment) values('Bogdanov Igor', 'Minsk, Pobediteley Ave. 48','+375(44)512-11-12',2,3,400,1,sysdate,200,50,'Yes','Yes',NULL,'Grishin P.P.','Grodno, Marchenko str. 23','+375(44)512-21-23',3,1,'No');

2:
UPDATE orders
SET ord_sender_birth_day = DATE '2002-10-16'
WHERE order_num = 4;

UPDATE orders
SET ORD_sender_name = 'Kanye West'
WHERE ORD_sender_name = 'JAY Z';

____END____.


____TASK____: 
3.МУТАЦИИ: 
СОЗДАЕМ КОЛОНКУ, КОТОРАЯ БУДЕТ 
ЕСЛИ ЗАКАН ЗАБРАН, НО ОБНОВИТЬ КОЛОНКУ
С ДАТОЙ, КОГДА ПОСЫЛКУ ЗАБРАЛИ

ЕСЛИ ПОСЫЛКУ ЗАБРАЛИ, ТО МЕНЯЕТСЯ ЗНАЧЕНИЕ КОЛОНКИ ord_picked_up 
ТОГДА ДОЛЖНА ОБНОВЛЯТЬСЯ КОЛОНКА С ДАТОЙ, КОГДА ЗАКАЗ ЗАБРАЛИ.
РАБОТНИК НАЖИМАЕТ - "ЗАКАЗ ЗАБРАН", А В БАЗЕ 
СОХРАНЯЕТСЯ ДЕНЬ И ВРЕМЯ, КОГДА ЗАКАЗ БЫЛ ЗАБРАН
----------------------------ИСХОДНЫЙ ВАРИАНТ-----------------------------
____CODE____:
create or replace trigger trg1
before INSERT OR UPDATE of ord_picked_up
on orders 
for each row
begin
	if(:new.ord_picked_up = 'Yes') then
     
	 update orders
         set ord_picked_up_date = current_timestamp
       where order_num = :new.order_num;
    end if;
  
  dbms_output.put_line('hellll_1');
end trg1; 
/

____TESTING____:
	 update orders
         set ord_picked_up = 'Yes'
       where order_num = 2;

RESULT: SQL>  update orders
  2           set ord_picked_up = 'Yes'
  3         where order_num = 1;
BIRTH: 12-SEP-03
cost: 31.1
CELEBRATE
 update orders
*
ERROR at line 1:
ORA-04091: table IOSU_LABS.ORDERS is mutating, trigger/function may not see it
ORA-06512: at "IOSU_LABS.TRG1", line 4
ORA-04088: error during execution of trigger 'IOSU_LABS.TRG1'

----------------------------ИСПРАВЛЕННЫЙ ВАРИАНТ-----------------------------
____CODE____:
CREATE OR REPLACE PACKAGE pkg_around_mutation AS
  pUpdPickUpState boolean default false;
  order_number orders.Order_num%type;
  procedure update_picked_up_state; 
END;
/

create or replace package body pkg_around_mutation
is
  procedure update_picked_up_state
  is 
  begin   
    if pUpdPickUpState then
      pUpdPickUpState := false;
		
	update orders
		set ord_picked_up_date = current_timestamp
	where order_num = pkg_around_mutation.order_number;
	
    end if;
	
  end update_picked_up_state;

end pkg_around_mutation;
/


create or replace trigger trg1
before INSERT OR UPDATE of ord_picked_up
on orders 
for each row
begin
	if(:new.ord_picked_up = 'Yes') then 
		pkg_around_mutation.order_number := :new.Order_num;
		pkg_around_mutation.pUpdPickUpState := true;  
	end if;
	
end trg1; 
/

create or replace trigger trg2
after insert or update of ord_picked_up
on orders
begin
  pkg_around_mutation.update_picked_up_state;  
end trg2;
/ 


____TESTING____:
	update orders
        set ord_picked_up = 'Yes'
    where order_num = 2;

____END____.


____TASK____: 
4. планировщик:
раз в месяц копировать строки с заказами, которые забрали(галочка столбца с мутацией)

планировщика задач, который будет раз в месяц копировать строки с заказами, которые забрали и
 должен быть настроен на многократный запуск с использованием частоты, интервала и спецификаторов.

ДОБАВЛЯЮ СТОЛБЕЦ ТИПА BOOL, КОТОРЫЙ БУДЕТ СОХРАНЯТЬ ЗНАЧЕНИЕ О ТОМ, ЗАБРАЛИ 
ПОСЫЛКУ ИЛИ НЕТ

ALTER TABLE orders 
add ord_picked_up varchar2(3) DEFAULT 'No';

alter table orders add CONSTRAINT ORD_order_picked_up
CHECK(ord_picked_up IN('Yes','No'));

И, ДОБАВЛЯЮ СТОЛБЕЦ, КОТОРЫЙ БУДЕТ ХРАНИТЬ ДАТУ, КОГДА ПОСЫЛКУ ЗАБРАЛИ

ALTER TABLE orders 
ADD ord_picked_up_date TIMESTAMP;

____CODE____:
CREATE TABLE order_archive(
					order_archive_id INTEGER generated by default as identity(nocache),
					Order_num INTEGER,
					ORD_sender_name VARCHAR2(40) NOT NULL,
					ORD_sender_address VARCHAR2(50) NOT NULL,
					ORD_sender_phone CHAR(17) NOT NULL,
					ORD_sending_office INTEGER NOT NULL,
					ORD_employee_placing_the_order_num INTEGER NOT NULL,
					ORD_package_weight DECIMAL(20,3) NOT NULL,
					ORD_package_scope DECIMAL(20,3) NOT NULL,
                    ORD_package_receipt_date DATE NOT NULL,
					ORD_declared_value_amount DECIMAL(30,3),
					ORD_cash_on_dlvry_amount DECIMAL(30,3),
					ORD_fragile VARCHAR2(3) NOT NULL,
					ORD_completeness_check VARCHAR2(3) NOT NULL,
                    ORD_arrival_date DATE,
					ORD_recipient_name VARCHAR2(40) NOT NULL,
					ORD_recipient_address VARCHAR2(50) NOT NULL,
					ORD_recipient_phone CHAR(17) NOT NULL,
					ORD_receiving_office INTEGER NOT NULL,
					ORD_shipping_cost DECIMAL(30,3) NOT NULL,
					ORD_deliv_type_code INTEGER NOT NULL,
					ORD_cash_payment VARCHAR2(3) NOT NULL,
					ord_sender_birth_day DATE,
					ord_picked_up_date TIMESTAMP,
					ord_picked_up VARCHAR2(3),
					PRIMARY KEY(order_archive_id));


CREATE OR REPLACE PROCEDURE copy_orders
AS
  today_month number;
  prev_month number;
BEGIN
	select EXTRACT(MONTH FROM sysdate) into today_month from dual;

	if today_month = 1 then
		prev_month := 12;
	else
		prev_month := today_month - 1;
	end if;
	
  -- Копируем строки с заказами, которые забрали
  INSERT INTO order_archive(Order_num,ORD_sender_name,
					ORD_sender_address, ORD_sender_phone, ORD_sending_office,
					ORD_employee_placing_the_order_num,	ORD_package_weight,
					ORD_package_scope, ORD_package_receipt_date,
					ORD_declared_value_amount, ORD_cash_on_dlvry_amount,
					ORD_fragile, ORD_completeness_check, ORD_arrival_date,
					ORD_recipient_name, ORD_recipient_address, ORD_recipient_phone,
					ORD_receiving_office, ORD_shipping_cost, ORD_deliv_type_code,
					ORD_cash_payment, ord_sender_birth_day, ord_picked_up_date, ord_picked_up)
	SELECT Order_num,ORD_sender_name,
		   ORD_sender_address, ORD_sender_phone, ORD_sending_office,
		   ORD_employee_placing_the_order_num,    ORD_package_weight,
		   ORD_package_scope, ORD_package_receipt_date,
		   ORD_declared_value_amount, ORD_cash_on_dlvry_amount,
		   ORD_fragile, ORD_completeness_check, ORD_arrival_date,
		   ORD_recipient_name, ORD_recipient_address, ORD_recipient_phone,
		   ORD_receiving_office, ORD_shipping_cost, ORD_deliv_type_code,
		   ORD_cash_payment, ord_sender_birth_day, ord_picked_up_date, ord_picked_up
    FROM orders
    WHERE orders.ord_picked_up = 'Yes' and EXTRACT(MONTH FROM orders.ord_picked_up_date) = prev_month;
END;
/

BEGIN
DBMS_SCHEDULER.CREATE_JOB
( job_name => 'job_copy_orders',
 job_type => 'STORED_PROCEDURE',
 job_action => 'copy_orders',
 repeat_interval => 'FREQ=MINUTELY;INTERVAL=1',
 start_date => SYSTIMESTAMP,
 end_date => NULL,
 enabled => TRUE);

DBMS_SCHEDULER.ENABLE ('job_copy_orders');
END;
/

BEGIN
dbms_scheduler.drop_job('job_copy_orders');
END;
/

BEGIN
DBMS_SCHEDULER.CREATE_JOB
( job_name => 'job_copy_orders',
 job_type => 'STORED_PROCEDURE',
 job_action => 'copy_orders',
 repeat_interval => 'FREQ=MONTHLY;BYMONTHDAY=1',
 start_date => SYSTIMESTAMP,
 end_date => NULL,
 enabled => TRUE);

DBMS_SCHEDULER.ENABLE ('job_copy_orders');
END;
/
____TESTING____:
____END____.


____TASK____: 
6.	Написать триггер INSTEAD OF для работы с не обновляемым представлением, 
созданным после выполнения п. 2.4 задания к лабораторной работе №3, проверить 
DML-командами возможность обновления представления после включения триггера 
(логика работы триггера определяется спецификой предметной области варианта).

-- 2.3)Создать вертикальное или смешанное необновляемое представление, предназначенное для работы с основной таблицей 
-- БД (в представлении должны содержаться сведения из основной дочерней таблицы и/или корзины (если есть), но вместо 
-- внешних ключей использовать связанные данные родительских таблиц, понятные конечному пользователю представления);
-- 2.4) доказать необновляемость представления из предыдущего пункта, проверив возможность 
-- выполнения инструкций UPDATE, DELETE, INSERT над представлением. Сохранить полученный результат 
-- (сообщение об ошибке или об успешном выполнении), объяснить причины;
ALTER TRIGGER view2_third DISABLE;

create or replace view view2_third AS
select distinct 
orders.order_num as order_number,
orders.ORD_sender_name as order_sender_name,
orders.ORD_sender_address as order_sender_address,
orders.ORD_sender_phone as order_sender_phone,
orders.ORD_sending_office as order_sending_office,
orders.ORD_employee_placing_the_order_num as order_employe_placing_order,
orders.ORD_package_weight as order_package_weight,
orders.ORD_package_scope as order_package_scope,
orders.ORD_package_receipt_date as order_package_receipt_date,
orders.ORD_declared_value_amount as order_declared_value_amount,
orders.ORD_fragile as order_fragile,
orders.ORD_COMPLETENESS_CHECK as order_completeness,
orders.ORD_recipient_name as order_recipient_name,
orders.ORD_recipient_address as order_recipient_address,
orders.ORD_recipient_phone as order_recipient_phone,
orders.ORD_receiving_office as order_receiving_office,
orders.ORD_shipping_cost as order_shipping_cost,
orders.ORD_deliv_type_code as order_deliv_type_code,
orders.ORD_cash_payment as order_cash_payment,
orders.ORD_SENDER_BIRTH_DAY as order_sender_birth_date,
orders.ord_picked_up_date as order_picked_up_date,
orders.ord_picked_up as order_picked_up,
delivery_type.dlv_delivery_method as delivery_method,
branch.branch_num as branch_number,
branch.BR_address as branch_sending_office_address,
branch.BR_max_storage_capacity as branch_max_storage_capacity,
branch.BR_principal_employee_name as branch_princip_employee_name,
branch.BR_principal_employee_phone as branch_princip_employee_phone,
branch.BR_employee_num as branch_employee_num,
branch.BR_ceo_director as branch_ceo,
staff.stf_name as staff_name,
staff.STF_birth_date as staff_birth_date,
staff.STF_address as staff_address,
staff.STF_position_code as staff_pos_code,
staff.STF_email as staff_email,
staff.STF_passport_details as staff_passport_data,
staff.STF_branch_num as staff_branch_num,
staff.STF_phone_num as staff_phone_num
from orders
left join branch on orders.ORD_sending_office = branch.branch_num
left join delivery_type on orders.ORD_deliv_type_code = delivery_type.DLV_code
left join staff on orders.ORD_employee_placing_the_order_num = staff.Staff_num
where to_char(orders.ORD_package_receipt_date, 'MM') = '03';

select * from view2_third;

insert into view2_third(
order_sender_name, 
order_sender_address, 
order_sender_phone, 
--order_sending_office,
--order_employe_placing_order, 
order_package_weight, 
order_package_scope, 
order_package_receipt_date,
order_declared_value_amount, 
order_fragile, 
order_completeness,
order_recipient_name, 
order_recipient_address,
order_recipient_phone, 
order_receiving_office, 
--order_deliv_type_code,
order_cash_payment, 
order_sender_birth_date,
delivery_method, 
branch_sending_office_address, 
branch_max_storage_capacity, 
branch_employee_num, 
branch_ceo, 
staff_name, 
staff_birth_date,
staff_address,
staff_pos_code, 
staff_email, 
staff_passport_data, 
staff_phone_num)
values ('Luka Doncic', 
'Frunze Ave 27, Viciebsk', 
'+375(44)141-55-12',
100,
0.1,
DATE '2023-03-30', -- if sysdate then view won't be inserted. right way DATE '2023-03-30'
100,
'Yes',
'Yes',
'Michael Jordan',
'Praspiekt Kasmanaŭtaŭ 100, Grodno',
'+375(29)140-55-12',
3,
'Yes',
DATE '2003-03-30',
'Plain',
'Gup Vileyskoye Zhkkh, Ulitsa Partizanskaya 36',
30,
1,
16,
'Pusha T',
DATE '2003-09-30',
'Moskovskiy Prospekt 33, Viciebsk',
2,
'pusha_t@gmail.com',
'HB2661252',
'+375(29)100-66-12');


update view2_third
	set order_sender_name = 'medvedev'
where order_number = 3;


delete from view2_third
where order_number = 31;


____CODE____:

CREATE OR REPLACE TRIGGER order_info_insert
   INSTEAD OF UPDATE OR INSERT OR DELETE ON view2_third
   for each row
   DECLARE
     duplicate_info EXCEPTION;
     PRAGMA EXCEPTION_INIT (duplicate_info, -00001);
	 	 
	 uncorrect_date EXCEPTION;
     PRAGMA EXCEPTION_INIT (uncorrect_date, -00002);

	 invalid_order_num EXCEPTION;
     PRAGMA EXCEPTION_INIT (invalid_order_num, -00003);

	 t_branch_number integer;
	 t_delivery_method integer;
	 t_employee_number integer;
	 t_order_number integer;
	 t_temp_recieve_month char(2);
	 t_temp_recieve_date date;
	 
   BEGIN
	CASE
        WHEN INSERTING then
			if to_char(:new.order_package_receipt_date, 'MM') != '03' then
			RAISE uncorrect_date;
			end if;
			
			 insert into Delivery_type(DLV_delivery_method) 
			 values (:new.delivery_method);
				 
			 select DLV_code into t_delivery_method from delivery_type where DLV_delivery_method = :new.delivery_method;

			 insert into branch(BR_max_storage_capacity,BR_principal_employee_name,
			 BR_principal_employee_phone,BR_address,BR_employee_num, BR_ceo_director)
			 values (:new.branch_max_storage_capacity, :new.staff_name, :new.staff_phone_num,
			 :new.branch_sending_office_address, :new.branch_employee_num, :new.branch_ceo);
			 
			 select Branch_num into t_branch_number from Branch where BR_principal_employee_name = :new.staff_name;
			 --нужен номер отделения, чтобы сотруднику его определить
			 -- создаю работника, который будет главным в отделении и примет заказ
			 insert into staff(stf_name, STF_birth_date, STF_address,
			 stf_position_code,STF_email,STF_passport_details,
			 STF_branch_num,STF_phone_num) values (:new.staff_name,
			 :new.staff_birth_date, :new.staff_address, :new.staff_pos_code,
			 :new.staff_email, :new.staff_passport_data, t_branch_number, 
			 :new.staff_phone_num);
			 
			 select staff_num into t_employee_number from staff where stf_name = :new.staff_name;
			 
			insert into Orders(ORD_sender_name,ORD_sender_address,
			ORD_sender_phone,ORD_sending_office,ORD_employee_placing_the_order_num,
			ORD_package_weight,ORD_package_scope,ORD_package_receipt_date,
			ORD_declared_value_amount,ORD_fragile,ORD_completeness_check,ORD_recipient_name,
			ORD_recipient_address,ORD_recipient_phone,ORD_receiving_office,
			ORD_deliv_type_code,ORD_cash_payment,ORD_SENDER_BIRTH_DAY) 
			values(:new.order_sender_name, :new.order_sender_address,
			:new.order_sender_phone, t_branch_number, t_employee_number,
			:new.order_package_weight, :new.order_package_scope,
			:new.order_package_receipt_date, :new.order_declared_value_amount,
			:new.order_fragile, :new.order_completeness, :new.order_recipient_name, 
			:new.order_recipient_address, :new.order_recipient_phone, 
			:new.order_receiving_office, t_delivery_method, :new.order_cash_payment, 
			:new.order_sender_birth_date);
			
		when DELETING then			
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :old.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
		
			DELETE FROM ORDERS WHERE Order_num = :old.order_number;
		
		when updating('order_sender_name') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sender_name = :new.order_sender_name
			where order_num = :new.order_number;
	
			
		when updating('order_sender_address') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sender_address = :new.order_sender_address
			where order_num = :new.order_number;
			
		when updating('order_sender_phone') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sender_phone = :new.order_sender_phone
			where order_num = :new.order_number;
			
		when updating('order_sending_office') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_sending_office = :new.order_sending_office
			where order_num = :new.order_number;
			
		when updating('order_employe_placing_order') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_employee_placing_the_order_num = :new.order_employe_placing_order
			where order_num = :new.order_number;
			
		when updating('order_package_weight') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_package_weight = :new.order_package_weight
			where order_num = :new.order_number;
			
		when updating('order_package_scope') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_package_scope = :new.order_package_scope
			where order_num = :new.order_number;
			
		when updating('order_package_receipt_date') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_package_receipt_date = :new.order_package_receipt_date
			where order_num = :new.order_number;
			
		when updating('order_declared_value_amount') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_declared_value_amount = :new.order_declared_value_amount
			where order_num = :new.order_number;
			
		when updating('order_fragile') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_fragile = :new.order_fragile
			where order_num = :new.order_number;
			
		when updating('order_completeness') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_COMPLETENESS_CHECK = :new.order_completeness
			where order_num = :new.order_number;

		when updating('order_recipient_name') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_recipient_name = :new.order_recipient_name
			where order_num = :new.order_number;
			
		when updating('order_recipient_address') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_recipient_address = :new.order_recipient_address
			where order_num = :new.order_number;
			
		when updating('order_recipient_phone') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_recipient_phone = :new.order_recipient_phone
			where order_num = :new.order_number;
			
		when updating('order_receiving_office') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_receiving_office = :new.order_receiving_office
			where order_num = :new.order_number;
			
		when updating('order_shipping_cost') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_shipping_cost = :new.order_shipping_cost
			where order_num = :new.order_number;
			
		when updating('order_deliv_type_code') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_deliv_type_code = :new.order_deliv_type_code
			where order_num = :new.order_number;
			
		when updating('order_cash_payment') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_cash_payment = :new.order_cash_payment
			where order_num = :new.order_number;
			
		when updating('order_sender_birth_date') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ORD_SENDER_BIRTH_DAY = :new.order_sender_birth_date
			where order_num = :new.order_number;
			
		when updating('order_picked_up_date') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ord_picked_up_date = :new.order_picked_up_date
			where order_num = :new.order_number;
			
		when updating('order_picked_up') then
			select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			from orders where order_num = :new.order_number;
			
			if t_temp_recieve_month != '03' then
			RAISE uncorrect_date;
			end if;			
			
			update orders
				set ord_picked_up = :new.order_picked_up
			where order_num = :new.order_number;
			
		-- when updating(delivery_method) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;		
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_number) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_sending_office_address) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_max_storage_capacity) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_princip_employee_name) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_princip_employee_phone) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_employee_num) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(branch_ceo) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_name) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_birth_date) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_address) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_pos_code) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_email) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_passport_data) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_branch_num) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;
		-- when updating(staff_phone_num) then
			-- select to_char(ORD_package_receipt_date, 'MM') into t_temp_recieve_month
			-- from orders where order_num = :new.order_number;
			
			-- if t_temp_recieve_month != '03' then
			-- RAISE uncorrect_date;
			-- end if;			
			
			-- update orders
				-- set ORD_sender_name = :new.order_sender_name
			-- where order_num = :new.order_number;		


end case;
		   
   EXCEPTION
     WHEN duplicate_info THEN
       RAISE_APPLICATION_ERROR (
         num=> -20107,
         msg=> 'Duplicate customer or order ID');
	 WHEN uncorrect_date THEN
       RAISE_APPLICATION_ERROR (
         num=> -20107,
         msg=> 'Uncorrect date');
	 WHEN invalid_order_num THEN
       RAISE_APPLICATION_ERROR (
         num=> -20107,
         msg=> 'There is no order with that number');

		 

END order_info_insert;
/


____TESTING____:


____END____.


-----------------------------18.10
когда главный отделения становится главным отделением 2 категории,
то сотрудники становятся сотрудниками 2 категории


insert INTO Positions(PST_name,PST_min_level_of_education_code,PST_min_salary,PST_employee_availability,PST_driver_license,PST_english_A2_required) VALUES 
('Employee_second_category', 1, 1000, 'No', 'No', 'No');

insert INTO Positions(pst_name,PST_min_level_of_education_code,PST_min_salary,PST_employee_availability,PST_driver_license,PST_english_A2_required) VALUES 
('Branch_chief_second_category', 3, 1700, 'Yes', 'No', 'Yes');
  
  
  
create or replace trigger trigger_mut
  for update of STF_position_code
  on staff
  compound trigger
    bUpdPainters  boolean;
 
  before each row is
  begin
    if :new.STF_name = 'Shobic I.P.' and :old.STF_position_code = 2 and :new.STF_position_code = 7 then
      bUpdPainters := true;
    end if;
  end before each row;
  
  after statement is
  begin
    if bUpdPainters then
      update staff
         set STF_position_code = 6
       where STF_position_code = 1;
    end if;
  end after statement;
end trigger_mut; 
/



update staff
   set STF_position_code = 7
 where STF_name = 'Shobic I.P.' and stf_branch_num = 1;


____TASK____: 
№3.курьер должен в день развозить не менее 5 посылок; меньше – штраф 1% от оклада; 
больше 10 – премия в размере 2% от зп - как будто, это разумно делать раз в сутки,
то есть планировщик нужен
____CODE____:
alter table Staff
add salary decimal(20,2);


____TESTING____:
____END____.


____TASK____: 
4. если сотрудник работает > года, то его минимальная зарплата увеличивается всегда на 20% от минимальной зарплаты
если сотрудник работает > 3 лет, то его минимальная зарплата увеличивается всегда на 30% от минимальной зарплаты
если сотрудник работает > 5 лет, то его минимальная зарплата увеличивается всегда на 50% от минимальной зарплаты
типо, раз в месяц
____CODE____:


____TESTING____:
____END____.

--------------------------------------------------------------------------------------------------------------------------------
