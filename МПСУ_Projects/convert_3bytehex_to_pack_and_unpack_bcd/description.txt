если текущее bcd число больше 5, то мы добавляем искусственно 3, для того, чтобы когда мы осуществили сдвиг(функцию rol), то
на месте bcd числа оказалось число, которое соответсвует bcd, то есть оно должно быть меньше 10, а добавляем мы именно 3, потому
что когда мы осуществляем функцию rol, то она же сдвигает все биты влево, да? верно! и она умножает тем самым числа на два, и
если мы умножим 3 на два, то получим 6, а это та самая разность между bcd и hex, которую нам нужно компенсировать, чтобы
благополучно осуществлять перевод из hex в bcd
0101 = 5 
+
0011 = 3
=
1000 = 8
rol
1 0000 = 16
16 = 8 * 2 = (3 + 5) * 2 = 3 * 2 + 5 * 2

это дает опять же возможность осуществлять переход в рамках 16-ричной системы, по итогу мы добавляем 6, чтобы 
компенсировать разность между системами счисления, и чтобы в bcd переменных хранились ликвидные значения, потому что
если мы не будем добавлять 3, то получится следующая ситуация
0101 = 5 
=
0101 = 5 
rol
0 1010 = 10 = А(в hex) 
но так как на выходе мы должны хранить числа только в bcd, 10 = А(в hex) просто не может там находится - это ошибка, и допустим,
чтобы выйти из этой ситуации, нам нужно добавить уже 6: 10 + 6 = 1 0000, но чтобы каждый раз этим не заниматься, мы можем
просто установить проверку перед операцией rol, и если текущее число больше 5, то будем добавлять 3, которое потом, после
умножения станет тем самым доп числом 6, которое позволит компенсировать разность между hex и bcd системами счисления